<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] XSLT versus 'traditional' templating
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20XSLT%20versus%20%27traditional%27%20templating&In-Reply-To=4125434B.1020904%40apnic.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016157.html">
   <LINK REL="Next"  HREF="016167.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] XSLT versus 'traditional' templating</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Scott Sanders</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20XSLT%20versus%20%27traditional%27%20templating&In-Reply-To=4125434B.1020904%40apnic.net"
       TITLE="[mod_python] XSLT versus 'traditional' templating">sanders at apache.org
       </A><BR>
    <I>Fri Aug 20 11:29:08 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="016157.html">[mod_python] XSLT versus 'traditional' templating
</A></li>
        <LI>Next message: <A HREF="016167.html">[mod_python] XSLT versus 'traditional' templating
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16166">[ date ]</a>
              <a href="thread.html#16166">[ thread ]</a>
              <a href="subject.html#16166">[ subject ]</a>
              <a href="author.html#16166">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Aug 19, 2004, at 5:18 PM, Byron Ellacott wrote:

&gt;<i> My basic problem here is that there are trivial XSLT fragments that 
</I>&gt;<i> may not be determinable until the entire source document has been 
</I>&gt;<i> read. Consider &lt;xsl:if test=&quot;/foo/bar&quot;&gt;There is a bar 
</I>&gt;<i> element&lt;/xsl:if&gt;.  In this example, a source document may have no bar 
</I>&gt;<i> elements at all, or it may have a bar element as the very last element 
</I>&gt;<i> before closing the root foo element.  An XSLT processor cannot 
</I>&gt;<i> distinguish these cases until the root element has been closed.
</I>
On the flip side, it can continue as soon as it sees a bar element. :)

&gt;<i>
</I>&gt;<i> If the bar element appeared earlier in the document, a sufficiently 
</I>&gt;<i> clever XSLT processor could continue processing as soon as that 
</I>&gt;<i> element was encountered, but this falls down when you consider:
</I>&gt;<i>
</I>&gt;<i> &lt;xsl:for-each select=&quot;/foo/bar&quot;&gt;Another bar found&lt;/xsl:for-each&gt;
</I>&gt;<i>
</I>&gt;<i> In this case, processing must be halted until the root element has 
</I>&gt;<i> been closed, since another bar element may be encountered at any time. 
</I>&gt;<i>  Once again, a clever processor could continue processing, storing 
</I>&gt;<i> tree fragments for later use, but it could not output any further 
</I>&gt;<i> elements until it was satisfied that the xsl:for-each had completed.
</I>
True

&gt;<i>
</I>&gt;<i> So, I can see how a sufficiently clever XSLT processor could stream 
</I>&gt;<i> output where possible, but this requires the stylesheet author to 
</I>&gt;<i> carefully avoid any construct that would cause output to block.
</I>
This is true.  Usually though (and this was the case in my app), you 
spit out a bunch of header html without complex expression evaluation), 
so the user starts to see the top of your page.  That's all it takes to 
convice them that the app is fast, and if anything is slow, it's their 
browser.

In places where we were doing complex evaluations, we either moved 
around the xml input to accomodate, or move complexity into a hand 
coded SAX filter above the XSLT processor.

A good XSLT processor will stream whenever it can.  It is up to the 
architect/designer/programmer to allow it to.

&gt;<i> Most notably, any XPath expression used to control transformation that 
</I>&gt;<i> cannot be sufficiently evaluated until the document is fully parsed 
</I>&gt;<i> must be avoided, and for any non-trivial use of XSLT, this is, to say 
</I>&gt;<i> the least, a hard task.
</I>
And it can usually be avoided very easily.

&gt;<i>
</I>&gt;<i> If I'm missing something here, please fill me in, because I am in the 
</I>&gt;<i> process of recommending an XML/XSLT approach to web development here 
</I>&gt;<i> at work, and I'd love to strike out the cost to perceived response 
</I>&gt;<i> times associated with a document transformation.
</I>
Make sure that XML is going to pay off first, and then XSLT can follow. 
  Don't let the cart lead the horse :)

Scott

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016157.html">[mod_python] XSLT versus 'traditional' templating
</A></li>
	<LI>Next message: <A HREF="016167.html">[mod_python] XSLT versus 'traditional' templating
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16166">[ date ]</a>
              <a href="thread.html#16166">[ thread ]</a>
              <a href="subject.html#16166">[ subject ]</a>
              <a href="author.html#16166">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
