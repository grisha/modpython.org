<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Some observations after writing my own modpython
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Some%20observations%20after%20writing%20my%20own%20modpython&In-Reply-To=4665881B.6080804%40rogerbinns.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023778.html">
   <LINK REL="Next"  HREF="023780.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Some observations after writing my own modpython</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Some%20observations%20after%20writing%20my%20own%20modpython&In-Reply-To=4665881B.6080804%40rogerbinns.com"
       TITLE="[mod_python] Some observations after writing my own modpython">graham.dumpleton at gmail.com
       </A><BR>
    <I>Tue Jun  5 18:45:02 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023778.html">[mod_python] Some observations after writing my own modpython
</A></li>
        <LI>Next message: <A HREF="023780.html">[mod_python] form POST, redirect to GET, lost POST
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23779">[ date ]</a>
              <a href="thread.html#23779">[ thread ]</a>
              <a href="subject.html#23779">[ subject ]</a>
              <a href="author.html#23779">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 06/06/07, Roger Binns &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">rogerb at rogerbinns.com</A>&gt; wrote:
&gt;<i> -----BEGIN PGP SIGNED MESSAGE-----
</I>&gt;<i> Hash: SHA1
</I>&gt;<i> &gt; The complaints one keep seeing about fastcgi/scgi is that it is a pain
</I>&gt;<i> &gt; to setup both in the fact that you need to install separate backend
</I>&gt;<i> &gt; packages and also in the configuration.
</I>&gt;<i>
</I>&gt;<i> Can't that be fixed by better documentation/installers?
</I>
Not all authors are that dedicated to come up with really good
documentation and why document a project written by someone else is
usually the attitude. Most will just spend just enough time to get it
working for themselves and leave it at that. Even more seem not even
to bother to read what documentation exists and will instead refer to
some arbitrary persons comments on a blog as to how they got it
working.

&gt;<i> &gt; You also see various
</I>&gt;<i> &gt; complaints about it those process will just die or will hang around
</I>&gt;<i> &gt; and not die.
</I>&gt;<i>
</I>&gt;<i> I assume that is bugs in wsgiref or one of the other servers.
</I>
Nothing to do with wsgiref as they aren't Python specific solutions.
The problem is more to do with how the supervisor mechanisms are
implemented for both those packages, or not as the case may be. In
mod_wsgi I use the Apache supervisor mechanism which because it is a
part of Apache should provide more of a guarantee that things get
cleaned up properly on shutdown and restart.

&gt;<i> &gt; Overall, the intent is to make it as secure, simple and uncomplicated
</I>&gt;<i> &gt; as possible for web hosting companies so they can see it as a viable
</I>&gt;<i> &gt; option for hosting Python web applications.
</I>&gt;<i>
</I>&gt;<i> I'd strongly recommend putting that paragraph at the top of the modwsgi
</I>&gt;<i> home page.  A problem with a lot of open source projects is that they
</I>&gt;<i> don't say what they are really good at.
</I>
True, I acknowledge I have a lot more work to do on documentation and
I do intend doing it. :-)

Also intend approaching some web hosting companies to see what they
think they need to be able to better support Python. Whether this be
features or simple documentation.

&gt;<i> &gt; Anyway, again, it is all about providing a system which is going to be
</I>&gt;<i> &gt; safe to use in shared web hosting environments where users can't
</I>&gt;<i> &gt; create havoc.
</I>&gt;<i>
</I>&gt;<i> def handler(...):
</I>&gt;<i>    while True:
</I>&gt;<i>       pass
</I>
Okay, less havoc. I should really phrase it as being 'where
administrators have more control over the users applications'. Problem
with mod_python for example is that even the entry points sit outside
of the Apache access/auth/authz mechanisms, plus having full access to
request details means one can do password harvesting and other nasty
things. It is also too easy in mod_python to force some of your code
to run in a distinct Python interpreter where code belonging to
someone else is running and thus interact with that other persons
code.

&gt;<i> &gt; Also, the apr_ functions
</I>&gt;<i> &gt; mean you are using the Apache memory pools. I didn't want to use the
</I>&gt;<i> &gt; memory pools as then the cumulative memory used is held until the end
</I>&gt;<i> &gt; of the request, whereas using malloc/free means only hold memory for
</I>&gt;<i> &gt; just the period I need to.
</I>&gt;<i>
</I>&gt;<i> I can't imagine requests live that long to matter.  Also if you are
</I>&gt;<i> talking premature optimizations, I believe it is far more effective to
</I>&gt;<i> have the one free called that gets rid of the whole pool rather than
</I>&gt;<i> individual frees.  The main thing that seemed wierd in the code is that
</I>&gt;<i> it was doing these precise allocations whereas I'd expect Python or apr
</I>&gt;<i> to do allocations larger than you requested so that when you add more
</I>&gt;<i> chunks of data the space is likely already there.
</I>
It is not the length of time for the request that matters, it is the
amount of data since if one uses Apache pools one can't give back
memory to the Apache pools such that it can be used straight away
within the lifetime of the pool, ie., one can't free it back to the
pool.

Also, in the log object, these aren't just used for 'wsgi.errors' for
life of request with them being used as replacements for 'sys.stdout'
and 'sys.stderr'. One can't use an Apache pool here as the log objects
live for the life of the interpreter (generally the process).

So, Apache pools are pretty well out unless one wants to add more code
complexity on top to deal with reusing memory etc. Even then still
problem of what to do with extra large chunks of memory if it has to
be allocated.

One could feasibly make use of stuff in Python to replace what I did
and I do use Python string objects at points where it is is easy and
makes sense. The only point I used malloc/free was where I needed to
retain buffered data between calls. For most cases where I did this,
the likelihood of the code actually being triggered is low as they
aren't on the most commonly used path. Thus for now it was a case of
getting something working. So yes it could be changed, but at this
point there is no pressing need.

&gt;<i> &gt;&gt; For the various objects that have a request_rec*, I don't see how they
</I>&gt;<i> &gt;&gt; deal with outliving the request_req.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; They don't and since I keep pushing this idea that mod_wsgi is meant
</I>&gt;<i> &gt; to be as secure and robust as possible to satisfy web hosting
</I>&gt;<i> &gt; companies, maybe I should.
</I>&gt;<i>
</I>&gt;<i> reqs=[]
</I>&gt;<i>
</I>&gt;<i> def handler(req):
</I>&gt;<i>    reqs.append(req)
</I>&gt;<i>    [r.uri for r in reqs]
</I>&gt;<i>
</I>&gt;<i> That code will cause a core dump :-)
</I>
I have already updated mod_wsgi to avoid such problems.

&gt;<i> &gt; Maybe I misunderstand what you are talking about, or to what level you
</I>&gt;<i> &gt; are applying it. What I thought you meant is that if one access an
</I>&gt;<i> &gt; attribute of request_rec, such as content type, that you create a
</I>&gt;<i> &gt; Python string object and return it, but that you also remember that
</I>&gt;<i> &gt; Python string instance so the next time content type is access in same
</I>&gt;<i> &gt; request, that Python string instance which is being held is return
</I>&gt;<i> &gt; instead of having to create a new one.
</I>&gt;<i>
</I>&gt;<i> OOR is not referring to individual attributes and &quot;small&quot; types such as
</I>&gt;<i> string and integer but rather objects such as what wraps the
</I>&gt;<i> request_rec, server, apr_tables etc.
</I>
Which is already done for request_rec and because of caching also for
the tables such as subprocess_env, notes, headers etc within a
mod_python request object. It isn't done for server_rec and conn_rec
within a request object however as I pointed out. Thus I think there
is perhaps more OOR going on in mod_python than may be obvious.

&gt;<i> &gt; Anyway, thanks greatly for reviewing my code and commenting on it.
</I>&gt;<i> &gt; Just about everyone grabs the code and uses it, rather than digging
</I>&gt;<i> &gt; into what it does and giving any feedback and how to make it better.
</I>&gt;<i>
</I>&gt;<i> You are welcome.  It was interesting for me too.
</I>
FWIW, I have gone through and made some changes to mod_wsgi based on
your comments. Some I see as much lower priority and will only revisit
if there appears to be a great need for it.

So much thanks still for your feedback.

Graham
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023778.html">[mod_python] Some observations after writing my own modpython
</A></li>
	<LI>Next message: <A HREF="023780.html">[mod_python] form POST, redirect to GET, lost POST
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23779">[ date ]</a>
              <a href="thread.html#23779">[ thread ]</a>
              <a href="subject.html#23779">[ subject ]</a>
              <a href="author.html#23779">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
