<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] focus on shared hosting?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20focus%20on%20shared%20hosting%3F&In-Reply-To=458BDAEC.7000503%40jgassociates.ca">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022844.html">
   <LINK REL="Next"  HREF="022881.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] focus on shared hosting?</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Sean Davis</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20focus%20on%20shared%20hosting%3F&In-Reply-To=458BDAEC.7000503%40jgassociates.ca"
       TITLE="[mod_python] focus on shared hosting?">sdavis2 at mail.nih.gov
       </A><BR>
    <I>Fri Dec 22 08:37:15 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022844.html">[mod_python] focus on shared hosting?
</A></li>
        <LI>Next message: <A HREF="022881.html">[mod_python] focus on shared hosting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22845">[ date ]</a>
              <a href="thread.html#22845">[ thread ]</a>
              <a href="subject.html#22845">[ subject ]</a>
              <a href="author.html#22845">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Friday 22 December 2006 08:17, Jim Gallacher wrote:
&gt;<i> Graham Dumpleton wrote:
</I>&gt;<i> &gt; On 22/12/2006, at 11:47 AM, Jeff Hinrichs - DM&amp;T wrote:
</I>&gt;<i> &gt;&gt; John Udell blogged today about django and mod_python.  However the
</I>&gt;<i> &gt;&gt; question he poses is pertinent to mod_python and projects that depend
</I>&gt;<i> &gt;&gt; on mp like TG and Pylons, et al.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; ...
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I know that there are a few hosts that specialize in python based apps
</I>&gt;<i> &gt;&gt; but what can be done to make mp a must have like php and ruby?  What
</I>&gt;<i> &gt;&gt; can be done technically to make mp a no-brainer decision for most web
</I>&gt;<i> &gt;&gt; hosting companies.  Are there really security or resource utilization
</I>&gt;<i> &gt;&gt; issues that can't be over come?  Maybe the next big mp focus should be
</I>&gt;<i> &gt;&gt; on what can be done to make administering/securing a shared mp install
</I>&gt;<i> &gt;&gt; so that it is easier for shared hosts to implement it.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Parts of what you are talking about are things I have been thinking
</I>&gt;<i> &gt; about quite a lot lately, which is, possible future directions for the
</I>&gt;<i> &gt; concept of using Python in conjunction with Apache. Note though that I
</I>&gt;<i> &gt; don't mention mod_python when I say this. :-)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The first thing one has to realise about people who want to use Python
</I>&gt;<i> &gt; for web programming is that the majority don't actually care what
</I>&gt;<i> &gt; mod_python is. Where they do want to use Apache, they see mod_python
</I>&gt;<i> &gt; merely as a convenient hopping off point. As such, you have frameworks
</I>&gt;<i> &gt; like Django, TurboGears, CherryPy and applications like Trac (latest)
</I>&gt;<i> &gt; and MoinMoin, which don't actually use any of the handlers supplied with
</I>&gt;<i> &gt; mod_python, nor its capabilities to do automatic module reloading,
</I>&gt;<i> &gt; forms, session handling etc.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; All these frameworks and applications want to do is specify a handler
</I>&gt;<i> &gt; to be called for the response phase, set up the Python module path and
</I>&gt;<i> &gt; possibly pass in a few options. When their handler is called, they then
</I>&gt;<i> &gt; promptly hide all the mod_python bits under a layer of code and the
</I>&gt;<i> &gt; user doesn't see them.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Further, where in the past these frameworks and applications built
</I>&gt;<i> &gt; separate adaptors for the various different web servers, they now all
</I>&gt;<i> &gt; tend to support WSGI. What one thus needs is not mod_python, but
</I>&gt;<i> &gt; mod_wsgi. The code needed to implement such a module would actually
</I>&gt;<i> &gt; be quite little in comparison to mod_python. In fact, none of the pure
</I>&gt;<i> &gt; Python code components of mod_python would even be required.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So what would a mod_wsgi need to contain. The first thing it needs to
</I>&gt;<i> &gt; be able to do is handle initialisation of Python and creation of
</I>&gt;<i> &gt; interpreter instances. This code would actually be much simpler than in
</I>&gt;<i> &gt; mod_python as mod_python has to do extra stuff like initialising global
</I>&gt;<i> &gt; mutexes for session management, trigger imports of special internal
</I>&gt;<i> &gt; modules when each interpreter instances is created, as well as importing
</I>&gt;<i> &gt; special user modules as well. In mod_wsgi it wouldn't need to do any of
</I>&gt;<i> &gt; that.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The next big difference with mod_wsgi in comparison to mod_python
</I>&gt;<i> &gt; would be that except to trigger its own initialisation, the only handler
</I>&gt;<i> &gt; phase it needs to hook and process is the response phase. Because it is
</I>&gt;<i> &gt; not hooking all phases, it would be much more efficient than mod_python
</I>&gt;<i> &gt; as it wouldn't be doing all that extra work for each request of checking
</I>&gt;<i> &gt; for mod_python handlers for each phase.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Next area where mod_python does more work than it needs to is with all
</I>&gt;<i> &gt; its configuration and options directives. Ie., PythonPath,
</I>&gt;<i> &gt; PythonAutoReload, PythonDebug, PythonOption. Apache already has a SetEnv
</I>&gt;<i> &gt; directive which can be used to set key value pairs with the values being
</I>&gt;<i> &gt; placed into the req.subprocess_env table object. Since other parts of
</I>&gt;<i> &gt; Apache already deal with doing that, mod_wsgi could just use SetEnv as
</I>&gt;<i> &gt; the means of getting any configuration information, with the
</I>&gt;<i> &gt; req.subprocess_env table also becoming the basis of the WSGI dictionary
</I>&gt;<i> &gt; which gets passed through to any WSGI handler. Even the definition of
</I>&gt;<i> &gt; what the WSGI handler module and function is, could be specified in this
</I>&gt;<i> &gt; way and as such mod_wsgi would not need to define any directives at all,
</I>&gt;<i> &gt; thus eliminating the need for code to handle them.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; To then setup mod_wsgi to be used, in the Apache configuration you would
</I>&gt;<i> &gt; have:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   &lt;Location /some/path&gt;
</I>&gt;<i> &gt;   SetHandler mod_wsgi
</I>&gt;<i> &gt;   SetEnv mod_wsgi.application module::application
</I>&gt;<i> &gt;   SetEnv mod_wsgi.interpreter myapplication
</I>&gt;<i> &gt;   SetEnv mod_wsgi.directory /directory/containing/module
</I>&gt;<i> &gt;   &lt;/Location&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Now in mod_python when a handler needs to be executed, a call is first
</I>&gt;<i> &gt; made into a dispatch function implemented in Python and it is that which
</I>&gt;<i> &gt; sets up all the environment and then calls the handler function. With
</I>&gt;<i> &gt; WSGI though, because the API for calling a WSGI application is so simple
</I>&gt;<i> &gt; it would be better to implement the dispatch in C code. Thus the C code
</I>&gt;<i> &gt; of mod_wsgi would import the application module and make the calls into
</I>&gt;<i> &gt; the application as appropriate. By doing this you totally eliminate the
</I>&gt;<i> &gt; need for any separate Python code modules needing to be installed and
</I>&gt;<i> &gt; thus get rid of one of the setup problems with mod_python of not being
</I>&gt;<i> &gt; able to find those extra Python modules. This should make it much easier
</I>&gt;<i> &gt; to install.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; One issue with web hosting environments especially is being able to
</I>&gt;<i> &gt; separate different users web applications. Although one can't have each
</I>&gt;<i> &gt; application run as a separate user, one can at least separate them into
</I>&gt;<i> &gt; distinct interpreters. To specify the interpreter one would use SetEnv
</I>&gt;<i> &gt; to set mod_wsgi.interpreter. Where you have a lot of applications
</I>&gt;<i> &gt; though, you might not want to have to manually set these. Although
</I>&gt;<i> &gt; mod_rewrite is itself a bit heavy weight, one of the things it can do is
</I>&gt;<i> &gt; set the same variables as SetEnv sets based on stuff which appears in
</I>&gt;<i> &gt; the URL. Thus one could with a mod_rewrite rule automatically specify
</I>&gt;<i> &gt; the interpreter name based on the request URL. This is something that
</I>&gt;<i> &gt; mod_python can't even do because it uses a directive for setting the
</I>&gt;<i> &gt; name of the interpreter.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; One final issue with interpreters is the initialisation of Python and
</I>&gt;<i> &gt; the creation of the interpreter instances. In this area, mod_wsgi could
</I>&gt;<i> &gt; run in one of two modes. The first would be where mod_wsgi is the only
</I>&gt;<i> &gt; Python module installed, ie. mod_python is not installed. In this
</I>&gt;<i> &gt; situation it could perform the initialisation of Python all itself and
</I>&gt;<i> &gt; also handle creation of interpreter instances. The second mode would be
</I>&gt;<i> &gt; where it detects that mod_python is already loaded. In this situation it
</I>&gt;<i> &gt; would simply use the hooks added in mod_python 3.3 for using
</I>&gt;<i> &gt; mod_python's machinery for accessing Python interpreter instances. By
</I>&gt;<i> &gt; being able to operate in these two modes, the module could either exist
</I>&gt;<i> &gt; by itself, but if needed, also co-operate with mod_python. Thus, just
</I>&gt;<i> &gt; because you run mod_wsgi doesn't mean that you couldn't also run
</I>&gt;<i> &gt; mod_wsgi at the same time.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If you have followed what I am talking about, and understand mod_python
</I>&gt;<i> &gt; internals and Apache a bit, you will see that the code for mod_wsgi
</I>&gt;<i> &gt; would actually be quite simple and because it doesn't have to wrap any
</I>&gt;<i> &gt; Apache data structures in Python equivalents, it should be quite easy to
</I>&gt;<i> &gt; create a version which is capable of being compiled on Apache 1.3, 2.0
</I>&gt;<i> &gt; or 2.2.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As I mention above, most people don't need the full mod_python
</I>&gt;<i> &gt; and thus this would allow all these higher level applications to still
</I>&gt;<i> &gt; be able to be run (under WSGI) even though they are using an older
</I>&gt;<i> &gt; version of Apache. This would also make it much simpler for web hosting
</I>&gt;<i> &gt; services as well, as they can say that they support anything which is
</I>&gt;<i> &gt; WSGI compliant.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Now, the idea of mod_wsgi is only one part of what I have been thinking
</I>&gt;<i> &gt; about for future directions of Python with Apache. It is late now though
</I>&gt;<i> &gt; so I'll go into my other ideas in the coming days, that is if I don't now
</I>&gt;<i> &gt; decide to go and finish my mod_wsgi which I already have the basis for in
</I>&gt;<i> &gt; place and thus get diverted. :-)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Comments on this part of my plans for global domination most welcome.
</I>&gt;<i>
</I>&gt;<i> Wow, what a good idea. (both mod_wsgi and world domination). Mod_wsgi
</I>&gt;<i> could pretty much be the mod_python-lite that Anthony spoke of earlier.
</I>&gt;<i> Could mod_python be made forward compatible with mod_wsgi? That way a
</I>&gt;<i> could site start with mod_wsgi but then easily switch to mod_python if
</I>&gt;<i> its additional features where required.
</I>
Or something in between mod_wsgi and the current mod_python, approaching 
something like mod_perl that tries to do less than mod_python, but still 
maintains hooks to the other phases of the request cycle.  (I have VERY 
LITTLE understandings of the innards of apache, so I don't know what such a 
solution might entail).

Sean
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022844.html">[mod_python] focus on shared hosting?
</A></li>
	<LI>Next message: <A HREF="022881.html">[mod_python] focus on shared hosting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22845">[ date ]</a>
              <a href="thread.html#22845">[ thread ]</a>
              <a href="subject.html#22845">[ subject ]</a>
              <a href="author.html#22845">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
