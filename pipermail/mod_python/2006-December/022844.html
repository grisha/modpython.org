<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] focus on shared hosting?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20focus%20on%20shared%20hosting%3F&In-Reply-To=1166789545.3712%40dscpl.user.openhosting.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022841.html">
   <LINK REL="Next"  HREF="022845.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] focus on shared hosting?</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Jim Gallacher</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20focus%20on%20shared%20hosting%3F&In-Reply-To=1166789545.3712%40dscpl.user.openhosting.com"
       TITLE="[mod_python] focus on shared hosting?">jpg at jgassociates.ca
       </A><BR>
    <I>Fri Dec 22 08:17:32 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022841.html">[mod_python] focus on shared hosting?
</A></li>
        <LI>Next message: <A HREF="022845.html">[mod_python] focus on shared hosting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22844">[ date ]</a>
              <a href="thread.html#22844">[ thread ]</a>
              <a href="subject.html#22844">[ subject ]</a>
              <a href="author.html#22844">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Graham Dumpleton wrote:
&gt;<i> On 22/12/2006, at 11:47 AM, Jeff Hinrichs - DM&amp;T wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> John Udell blogged today about django and mod_python.  However the
</I>&gt;&gt;<i> question he poses is pertinent to mod_python and projects that depend
</I>&gt;&gt;<i> on mp like TG and Pylons, et al.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I know that there are a few hosts that specialize in python based apps
</I>&gt;&gt;<i> but what can be done to make mp a must have like php and ruby?  What
</I>&gt;&gt;<i> can be done technically to make mp a no-brainer decision for most web
</I>&gt;&gt;<i> hosting companies.  Are there really security or resource utilization
</I>&gt;&gt;<i> issues that can't be over come?  Maybe the next big mp focus should be
</I>&gt;&gt;<i> on what can be done to make administering/securing a shared mp install
</I>&gt;&gt;<i> so that it is easier for shared hosts to implement it.
</I>&gt;<i> 
</I>&gt;<i> Parts of what you are talking about are things I have been thinking
</I>&gt;<i> about quite a lot lately, which is, possible future directions for the
</I>&gt;<i> concept of using Python in conjunction with Apache. Note though that I
</I>&gt;<i> don't mention mod_python when I say this. :-)
</I>&gt;<i> 
</I>&gt;<i> The first thing one has to realise about people who want to use Python
</I>&gt;<i> for web programming is that the majority don't actually care what
</I>&gt;<i> mod_python is. Where they do want to use Apache, they see mod_python
</I>&gt;<i> merely as a convenient hopping off point. As such, you have frameworks
</I>&gt;<i> like Django, TurboGears, CherryPy and applications like Trac (latest)
</I>&gt;<i> and MoinMoin, which don't actually use any of the handlers supplied with
</I>&gt;<i> mod_python, nor its capabilities to do automatic module reloading,
</I>&gt;<i> forms, session handling etc.
</I>&gt;<i> 
</I>&gt;<i> All these frameworks and applications want to do is specify a handler
</I>&gt;<i> to be called for the response phase, set up the Python module path and
</I>&gt;<i> possibly pass in a few options. When their handler is called, they then
</I>&gt;<i> promptly hide all the mod_python bits under a layer of code and the
</I>&gt;<i> user doesn't see them.
</I>&gt;<i> 
</I>&gt;<i> Further, where in the past these frameworks and applications built
</I>&gt;<i> separate adaptors for the various different web servers, they now all
</I>&gt;<i> tend to support WSGI. What one thus needs is not mod_python, but
</I>&gt;<i> mod_wsgi. The code needed to implement such a module would actually
</I>&gt;<i> be quite little in comparison to mod_python. In fact, none of the pure
</I>&gt;<i> Python code components of mod_python would even be required.
</I>&gt;<i> 
</I>&gt;<i> So what would a mod_wsgi need to contain. The first thing it needs to
</I>&gt;<i> be able to do is handle initialisation of Python and creation of interpreter
</I>&gt;<i> instances. This code would actually be much simpler than in mod_python
</I>&gt;<i> as mod_python has to do extra stuff like initialising global mutexes for
</I>&gt;<i> session management, trigger imports of special internal modules when
</I>&gt;<i> each interpreter instances is created, as well as importing special user
</I>&gt;<i> modules as well. In mod_wsgi it wouldn't need to do any of that.
</I>&gt;<i> 
</I>&gt;<i> The next big difference with mod_wsgi in comparison to mod_python
</I>&gt;<i> would be that except to trigger its own initialisation, the only handler
</I>&gt;<i> phase it needs to hook and process is the response phase. Because it is
</I>&gt;<i> not hooking all phases, it would be much more efficient than mod_python
</I>&gt;<i> as it wouldn't be doing all that extra work for each request of checking
</I>&gt;<i> for mod_python handlers for each phase.
</I>&gt;<i> 
</I>&gt;<i> Next area where mod_python does more work than it needs to is with all
</I>&gt;<i> its configuration and options directives. Ie., PythonPath, PythonAutoReload,
</I>&gt;<i> PythonDebug, PythonOption. Apache already has a SetEnv directive which
</I>&gt;<i> can be used to set key value pairs with the values being placed into the
</I>&gt;<i> req.subprocess_env table object. Since other parts of Apache already deal
</I>&gt;<i> with doing that, mod_wsgi could just use SetEnv as the means of getting
</I>&gt;<i> any configuration information, with the req.subprocess_env table also
</I>&gt;<i> becoming the basis of the WSGI dictionary which gets passed through
</I>&gt;<i> to any WSGI handler. Even the definition of what the WSGI handler module
</I>&gt;<i> and function is, could be specified in this way and as such mod_wsgi would
</I>&gt;<i> not need to define any directives at all, thus eliminating the need for code
</I>&gt;<i> to handle them.
</I>&gt;<i> 
</I>&gt;<i> To then setup mod_wsgi to be used, in the Apache configuration you would
</I>&gt;<i> have:
</I>&gt;<i> 
</I>&gt;<i>   &lt;Location /some/path&gt;
</I>&gt;<i>   SetHandler mod_wsgi
</I>&gt;<i>   SetEnv mod_wsgi.application module::application
</I>&gt;<i>   SetEnv mod_wsgi.interpreter myapplication
</I>&gt;<i>   SetEnv mod_wsgi.directory /directory/containing/module
</I>&gt;<i>   &lt;/Location&gt;
</I>&gt;<i> 
</I>&gt;<i> Now in mod_python when a handler needs to be executed, a call is first
</I>&gt;<i> made into a dispatch function implemented in Python and it is that which
</I>&gt;<i> sets up all the environment and then calls the handler function. With
</I>&gt;<i> WSGI though, because the API for calling a WSGI application is so simple
</I>&gt;<i> it would be better to implement the dispatch in C code. Thus the C code
</I>&gt;<i> of mod_wsgi would import the application module and make the calls into
</I>&gt;<i> the application as appropriate. By doing this you totally eliminate the
</I>&gt;<i> need for any separate Python code modules needing to be installed and
</I>&gt;<i> thus get rid of one of the setup problems with mod_python of not being
</I>&gt;<i> able to find those extra Python modules. This should make it much easier
</I>&gt;<i> to install.
</I>&gt;<i> 
</I>&gt;<i> One issue with web hosting environments especially is being able to
</I>&gt;<i> separate different users web applications. Although one can't have each
</I>&gt;<i> application run as a separate user, one can at least separate them into
</I>&gt;<i> distinct interpreters. To specify the interpreter one would use SetEnv
</I>&gt;<i> to set mod_wsgi.interpreter. Where you have a lot of applications
</I>&gt;<i> though, you might not want to have to manually set these. Although
</I>&gt;<i> mod_rewrite is itself a bit heavy weight, one of the things it can do is
</I>&gt;<i> set the same variables as SetEnv sets based on stuff which appears in
</I>&gt;<i> the URL. Thus one could with a mod_rewrite rule automatically specify
</I>&gt;<i> the interpreter name based on the request URL. This is something that
</I>&gt;<i> mod_python can't even do because it uses a directive for setting the
</I>&gt;<i> name of the interpreter.
</I>&gt;<i> 
</I>&gt;<i> One final issue with interpreters is the initialisation of Python and
</I>&gt;<i> the creation of the interpreter instances. In this area, mod_wsgi could
</I>&gt;<i> run in one of two modes. The first would be where mod_wsgi is the only
</I>&gt;<i> Python module installed, ie. mod_python is not installed. In this
</I>&gt;<i> situation it could perform the initialisation of Python all itself and
</I>&gt;<i> also handle creation of interpreter instances. The second mode would be
</I>&gt;<i> where it detects that mod_python is already loaded. In this situation it
</I>&gt;<i> would simply use the hooks added in mod_python 3.3 for using
</I>&gt;<i> mod_python's machinery for accessing Python interpreter instances. By
</I>&gt;<i> being able to operate in these two modes, the module could either exist
</I>&gt;<i> by itself, but if needed, also co-operate with mod_python. Thus, just
</I>&gt;<i> because you run mod_wsgi doesn't mean that you couldn't also run
</I>&gt;<i> mod_wsgi at the same time.
</I>&gt;<i> 
</I>&gt;<i> If you have followed what I am talking about, and understand mod_python
</I>&gt;<i> internals and Apache a bit, you will see that the code for mod_wsgi
</I>&gt;<i> would actually be quite simple and because it doesn't have to wrap any
</I>&gt;<i> Apache data structures in Python equivalents, it should be quite easy to
</I>&gt;<i> create a version which is capable of being compiled on Apache 1.3, 2.0
</I>&gt;<i> or 2.2.
</I>&gt;<i> 
</I>&gt;<i> As I mention above, most people don't need the full mod_python
</I>&gt;<i> and thus this would allow all these higher level applications to still
</I>&gt;<i> be able to be run (under WSGI) even though they are using an older
</I>&gt;<i> version of Apache. This would also make it much simpler for web hosting
</I>&gt;<i> services as well, as they can say that they support anything which is
</I>&gt;<i> WSGI compliant.
</I>&gt;<i> 
</I>&gt;<i> Now, the idea of mod_wsgi is only one part of what I have been thinking
</I>&gt;<i> about for future directions of Python with Apache. It is late now though so
</I>&gt;<i> I'll go into my other ideas in the coming days, that is if I don't now decide
</I>&gt;<i> to go and finish my mod_wsgi which I already have the basis for in place
</I>&gt;<i> and thus get diverted. :-)
</I>&gt;<i> 
</I>&gt;<i> Comments on this part of my plans for global domination most welcome.
</I>
Wow, what a good idea. (both mod_wsgi and world domination). Mod_wsgi 
could pretty much be the mod_python-lite that Anthony spoke of earlier. 
Could mod_python be made forward compatible with mod_wsgi? That way a 
could site start with mod_wsgi but then easily switch to mod_python if 
its additional features where required.

This is definitely something would should talk about in the new year.

Jim



</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022841.html">[mod_python] focus on shared hosting?
</A></li>
	<LI>Next message: <A HREF="022845.html">[mod_python] focus on shared hosting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22844">[ date ]</a>
              <a href="thread.html#22844">[ thread ]</a>
              <a href="subject.html#22844">[ subject ]</a>
              <a href="author.html#22844">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
