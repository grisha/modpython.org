<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] focus on shared hosting?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20focus%20on%20shared%20hosting%3F&In-Reply-To=200612220837.15168.sdavis2%40mail.nih.gov">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022845.html">
   <LINK REL="Next"  HREF="022895.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] focus on shared hosting?</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20focus%20on%20shared%20hosting%3F&In-Reply-To=200612220837.15168.sdavis2%40mail.nih.gov"
       TITLE="[mod_python] focus on shared hosting?">grahamd at dscpl.com.au
       </A><BR>
    <I>Wed Dec 27 00:37:40 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022845.html">[mod_python] focus on shared hosting?
</A></li>
        <LI>Next message: <A HREF="022895.html">[mod_python] focus on shared hosting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22881">[ date ]</a>
              <a href="thread.html#22881">[ thread ]</a>
              <a href="subject.html#22881">[ subject ]</a>
              <a href="author.html#22881">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Some delayed comments on some old posts.

On 23/12/2006, at 12:37 AM, Sean Davis wrote:

&gt;<i> On Friday 22 December 2006 08:17, Jim Gallacher wrote:
</I>&gt;&gt;<i> Graham Dumpleton wrote:
</I>&gt;&gt;&gt;<i> If you have followed what I am talking about, and understand  
</I>&gt;&gt;&gt;<i> mod_python
</I>&gt;&gt;&gt;<i> internals and Apache a bit, you will see that the code for mod_wsgi
</I>&gt;&gt;&gt;<i> would actually be quite simple and because it doesn't have to  
</I>&gt;&gt;&gt;<i> wrap any
</I>&gt;&gt;&gt;<i> Apache data structures in Python equivalents, it should be quite  
</I>&gt;&gt;&gt;<i> easy to
</I>&gt;&gt;&gt;<i> create a version which is capable of being compiled on Apache  
</I>&gt;&gt;&gt;<i> 1.3, 2.0
</I>&gt;&gt;&gt;<i> or 2.2.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> As I mention above, most people don't need the full mod_python
</I>&gt;&gt;&gt;<i> and thus this would allow all these higher level applications to  
</I>&gt;&gt;&gt;<i> still
</I>&gt;&gt;&gt;<i> be able to be run (under WSGI) even though they are using an older
</I>&gt;&gt;&gt;<i> version of Apache. This would also make it much simpler for web  
</I>&gt;&gt;&gt;<i> hosting
</I>&gt;&gt;&gt;<i> services as well, as they can say that they support anything  
</I>&gt;&gt;&gt;<i> which is
</I>&gt;&gt;&gt;<i> WSGI compliant.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Now, the idea of mod_wsgi is only one part of what I have been  
</I>&gt;&gt;&gt;<i> thinking
</I>&gt;&gt;&gt;<i> about for future directions of Python with Apache. It is late now  
</I>&gt;&gt;&gt;<i> though
</I>&gt;&gt;&gt;<i> so I'll go into my other ideas in the coming days, that is if I  
</I>&gt;&gt;&gt;<i> don't now
</I>&gt;&gt;&gt;<i> decide to go and finish my mod_wsgi which I already have the  
</I>&gt;&gt;&gt;<i> basis for in
</I>&gt;&gt;&gt;<i> place and thus get diverted. :-)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Comments on this part of my plans for global domination most  
</I>&gt;&gt;&gt;<i> welcome.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Wow, what a good idea. (both mod_wsgi and world domination). Mod_wsgi
</I>&gt;&gt;<i> could pretty much be the mod_python-lite that Anthony spoke of  
</I>&gt;&gt;<i> earlier.
</I>&gt;&gt;<i> Could mod_python be made forward compatible with mod_wsgi? That way a
</I>&gt;&gt;<i> could site start with mod_wsgi but then easily switch to  
</I>&gt;&gt;<i> mod_python if
</I>&gt;&gt;<i> its additional features where required.
</I>
People run WSGI stuff on mod_python now, so upgrade path shouldn't be a
problem as the handler acting as the gateway would hide any differences
in underlying API which is effectively the whole point of WSGI, ie.,  
make it
run anywhere. That said, how one configures the handler for each may  
need
to be a bit different.

&gt;<i> Or something in between mod_wsgi and the current mod_python,  
</I>&gt;<i> approaching
</I>&gt;<i> something like mod_perl that tries to do less than mod_python, but  
</I>&gt;<i> still
</I>&gt;<i> maintains hooks to the other phases of the request cycle.  (I have  
</I>&gt;<i> VERY
</I>&gt;<i> LITTLE understandings of the innards of apache, so I don't know  
</I>&gt;<i> what such a
</I>&gt;<i> solution might entail).
</I>
It is interesting that you see mod_perl lying between mod_wsgi (a cut  
down
mod_python) and mod_python. In fact mod_perl allows a lot more to be  
done
than mod_python in that it exposes all the Apache innards and API to  
view.
With mod_python it is providing a restricted API that hides most of what
Apache provides and with the API not being similar at all. This  
approach and
the fact that the mod_python API on top of Apache is all explicitly  
coded is
quite limiting and makes maintenance and extension of mod_python a pain.

As to whether it is possible to implement a mod_perl like module for  
Python,
it is, it can work and it is simpler than one might expect as SWIG  
works quite
well for this. I already have basic bindings working as proof of  
concept.

Working out what to do with these new Python bindings for Apache is the
problem as it isn't necessarily straight forward to see how they  
might fit into
the future of mod_python. The main problem is that mod_python got there
first and has the market share. Even if one brought out a new module for
using Python with Apache which is technically a better and more  
efficient
solution, it is going to be hard to dislodge mod_python. Thus, having  
a new
module which requires you can't run the old one is probably impractical.

What are the solutions to this. The first is to acknowledge that  
mod_python got
there first and for any new module to recognise when mod_python is also
running and for the new module to utilise the Python interpreter  
initialisation
and creation code in mod_python through Apache hook functions. This is
to a degree now possible with mod_python 3.3.0b, however as I have  
learnt
since I added that ability to mod_python, the whole way mod_python  
handles
Python initialisation is far from optimal and would impose certain  
limitations
on any new module. Thus, for this to work effectively, the lower  
level layer of
mod_python needs to be reworked so that Python initialisation is done at
a more appropriate time and in a more modular way so that separate  
modules
can harness it better.

So, in this approach, if the new module is the only one loaded, it  
would do
all the initialisation itself. If mod_python is loaded as well, it  
would defer to
mod_python as the incumbent system. A problem with this though is  
that all
processing is then going to be weighed down with the checking done by
both modules in every phase. So, although it may be good in that it  
allows
both to run, it is unlikely that people would want to run both and so  
the
incumbent will probably still win.

The second option is to implement the new module as a broad enough
framework that the existing mod_python API could be implemented as a
personality on top of it. So, one looks at this other way around and  
says that
the new module is technically a much better solution and bless it as  
the way
forward. The API of mod_python could then be supported as just one of  
many
restrictive APIs on top of the new module, thus allowing support of  
older code
as well as allowing development of new personalities and extension  
modules
for Apache. As a further example, WSGI could be just another personality
on top of the new module.

With a new module which exposes better the Apache APIs, examples of
things you could do are:

   mod_authn_python - Implement an auth provider using Python code.

   mod_dav_python - Implement a dav provider using Python code.

One could also effectively break up the monolithic feature set of  
mod_python
into smaller bits, thereby allowing users to choose the bits they  
need thereby
limiting the overhead on the server of the bits they don't want. As  
such, one
could have:

   mod_python_handlers - Implementation of hooks for handler phases.

   mod_python_filters - Implementation of hooks for input/output  
filters.

   mod_include_python - Implementation of Python code in server side  
include.

Although technically this solution of implementing the existing  
mod_python
API on top of a new module may be a good way of doing it, I feel that  
it is
also doomed to failed, this time because of politics and the  
unwillingness of
people to accept that such a drastic change is even required. There  
are much
lesser issues related to mod_python already which decisions can't  
even be
made about, so hardly expect any agreement on any sort of future  
direction
for mod_python along these lines.

So, although I may have grand plans for world domination along these  
lines,
in practice I don't see it going very far, at least not under the  
umbrella of the
existing mod_python project. What exactly I will do with these ideas  
and the
code I have already developed I don't know yet. I see I have two  
choices at
present. These are to work on it myself out of my own site as a personal
project purely for curiosity value. The second is to get an Apache  
labs project
created for it and work on it there. In the latter, because it is  
under the
umbrella of the Apache Software Foundation, it doesn't rule out it  
someday
perhaps being adopted as an official front line project. Doing it as  
an Apache
labs project would also make it easier to migrate at least some of  
the ideas over
to mod_python so as to improve the existing code base.

BTW, to give you an idea of what overheads/inefficiencies exist in the
mod_python code base I have done some comparative tests between a
C coded handler module, a mod_python handler function and a handler
function implemented using Apache SWIG bindings on a more streamlined
Python module for Apache that doesn't rely on mod_python.

On my quite slow PowerPC laptop the results I get for a basic hello  
world
response handler written entirely in C code averages about 1250 requests
per second.

For my cut down Python module invoking Python handler which uses SWIG
bindings it averages about 800 requests per second.

With mod_python it averages about 500 requests per second.

Thus, it would appear that there is certainly some room for  
improvement with
mod_python at least and if nothing else, maybe what I am doing might  
help
to identify the problems it has and make it run better. Other than  
that, I don't
know at this point.

Graham





</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022845.html">[mod_python] focus on shared hosting?
</A></li>
	<LI>Next message: <A HREF="022895.html">[mod_python] focus on shared hosting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22881">[ date ]</a>
              <a href="thread.html#22881">[ thread ]</a>
              <a href="subject.html#22881">[ subject ]</a>
              <a href="author.html#22881">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
