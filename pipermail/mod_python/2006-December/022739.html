<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] python path and 3.3
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20python%20path%20and%203.3&In-Reply-To=a595de7a0612011557q25ca850bsa5f81f6f29e90885%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022737.html">
   <LINK REL="Next"  HREF="022741.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] python path and 3.3</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20python%20path%20and%203.3&In-Reply-To=a595de7a0612011557q25ca850bsa5f81f6f29e90885%40mail.gmail.com"
       TITLE="[mod_python] python path and 3.3">grahamd at dscpl.com.au
       </A><BR>
    <I>Fri Dec  1 23:22:22 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022737.html">[mod_python] python path and 3.3
</A></li>
        <LI>Next message: <A HREF="022741.html">[mod_python] python path and 3.3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22739">[ date ]</a>
              <a href="thread.html#22739">[ thread ]</a>
              <a href="subject.html#22739">[ subject ]</a>
              <a href="author.html#22739">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On 02/12/2006, at 10:57 AM, Clodoaldo wrote:

&gt;&gt;<i> Ok, I did it and now this works:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> import constants as C
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> But this does not work:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> from mod_python import apache
</I>&gt;&gt;<i> C = apache.import_module('constants.py')
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Changed it to:
</I>&gt;<i>
</I>&gt;<i> from mod_python import apache
</I>&gt;<i> C = apache.import_module('~/mod/constants.py')
</I>&gt;<i>
</I>&gt;<i> And it works.
</I>
The apache.import_module() function is doing double duty in allowing
either a module name or a path for a file (including extension). For a
path it has to be able to be distinguishable from a module or module  
within
package name. Thus, for a path, can only use:

   /some/path/module.py
   ~/some/path/module.py
   ./some/path/module.py
   ../some/path/module.py

For anything else it assumes it is a normal module import. For  
'constants.py'
that thus means it thinks you are wanting to import a submodule  
called 'py'
from a package called 'constants'.

There are a few other quirks with the new importer. The first is that  
when a
path is specified, you don't actually need to use a .py extension.  
This means
for example that the mpservlets package which uses a .mps extension  
could
quite easily be rewritten to use the new module importer rather than  
its own
and get all the benefit of the full depth checks on module reloading.  
In other
words:

   module = apache.import_module(&quot;/some/path/servlet.mps&quot;)

will work.

This may be useful if you don't want to use a .py extension and want  
to use
something else to hide the fact that Python is being used.

Another strange characteristic of the new module importer, although this
also actually works in more recent Python versions if using __import__ 
(),
although not perhaps on all platforms, is that one can use a '/' to  
refer to a
module name in a subdirectory somewhere on the module search path.

What this means is that if you had used:

   PythonOption mod_python.importer.path &quot;['~/']&quot;

rather than:

   PythonOption mod_python.importer.path &quot;['~/mod']&quot;

you could then have said:

   apache.import_module('mod/constants')

Note that I haven't used a '.py' extension. In some way this is like  
having a
package, but the big difference is that the 'mod' directory doesn't  
have to be
an actual package, ie., no __init__.py file is required.

This method can thus be used to create a namespace for modules still,  
ie.,
by using a subdirectory, but since a package isn't being used, automatic
module reloading still works.

Since the same works with __import__() for some versions of Python,
falling back to using __import__() may be useful if you are trying to do
testing outside of mod_python.

Graham
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022737.html">[mod_python] python path and 3.3
</A></li>
	<LI>Next message: <A HREF="022741.html">[mod_python] python path and 3.3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22739">[ date ]</a>
              <a href="thread.html#22739">[ thread ]</a>
              <a href="subject.html#22739">[ subject ]</a>
              <a href="author.html#22739">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
