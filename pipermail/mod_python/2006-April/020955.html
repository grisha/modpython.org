<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] The new module loader
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20The%20new%20module%20loader&In-Reply-To=44490394.9050402%40joreybump.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020965.html">
   <LINK REL="Next"  HREF="020936.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] The new module loader</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20The%20new%20module%20loader&In-Reply-To=44490394.9050402%40joreybump.com"
       TITLE="[mod_python] The new module loader">grahamd at dscpl.com.au
       </A><BR>
    <I>Sat Apr 22 09:51:00 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020965.html">[mod_python] The new module loader
</A></li>
        <LI>Next message: <A HREF="020936.html">[mod_python] The new module loader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20955">[ date ]</a>
              <a href="thread.html#20955">[ thread ]</a>
              <a href="subject.html#20955">[ subject ]</a>
              <a href="author.html#20955">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Sorry for taking so long to get back to this email. Busy day ...

On 22/04/2006, at 2:08 AM, Jorey Bump wrote:

&gt;<i> Graham Dumpleton wrote:
</I>&gt;&gt;<i> Graham Dumpleton wrote ..
</I>&gt;&gt;&gt;<i> The new module importer completely ignores packages as it is  
</I>&gt;&gt;&gt;<i> practically
</I>&gt;&gt;&gt;<i> impossible to get any form of automatic module reloading to work
</I>&gt;&gt;&gt;<i> correctly with them when they are more than trivial. As such,  
</I>&gt;&gt;&gt;<i> packages
</I>&gt;&gt;&gt;<i> are handed off to standard Python __import__ to deal with. That  
</I>&gt;&gt;&gt;<i> it even
</I>&gt;&gt;&gt;<i> finds the package means that you have it installed in sys.path.  
</I>&gt;&gt;&gt;<i> Even if
</I>&gt;&gt;&gt;<i> it was a file based module, because it is on sys.path and thus  
</I>&gt;&gt;&gt;<i> likely to
</I>&gt;&gt;&gt;<i> be installed in a standard location, the new module importer  
</I>&gt;&gt;&gt;<i> would again
</I>&gt;&gt;&gt;<i> ignore it as it leaves all sys.path modules up to Python __import__
</I>&gt;&gt;&gt;<i> as too dangerous to be mixing importing schemes.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Anyway, that all only applies if you were expecting  
</I>&gt;&gt;&gt;<i> PyServer.pyserver to
</I>&gt;&gt;&gt;<i> automatically reload upon changes.
</I>&gt;<i>
</I>&gt;<i> Graham, can you enumerate the different ways packages are handled,  
</I>&gt;<i> or is it enough to say that packages are never reloaded? In this  
</I>&gt;<i> thread, you explain that when a package is imported via  
</I>&gt;<i> PythonHandler, mod_python uses the conventional Python __import__,  
</I>&gt;<i> requiring an apache restart to reliably reload the package, as in  
</I>&gt;<i> the past.
</I>
That is correct. What it means is that packages will only be found if
located somewhere along sys.path and are still held in sys.modules
because it is builtin Python __import__ that will load them. As such,  
they
are not regarded as being reloadable by mod_python. Whether you can
reload Packages using the Python &quot;reload&quot; statement/function I don't  
know
as I have never tried. I would probably not recommend trying, so an
Apache restart is still going to be the only way to reliably reload a  
package.
Therefore nothing has change in this respect from current importer.

I really did try hard to get reloading working with packages, ie., many
nights over a few weeks, but in the end although I could see a glimmer
of hope that it might work, it just became too impractical. Some of the
problems are that sub imports within packages will only work when the
parent module in the package is listed in sys.modules. Thus one had
to fake up horrible unique module reference names to store a reference
to the modules in sys.modules. Because of reloading, this had to be
tagged also with an incarnation version number so that when reloading
you weren't overwriting the currently loaded one. The other big problem
was that you get cyclic dependency loops in packages because of how
you reference back through the root of the package when doing sub
imports. This meant that any change to any module file within the
package had to trigger a complete reload of all files which made up
the package. Ie., you had to treat the package as a complete blob,
otherwise it became impossible to implement and you invariable some
how got different versions of a module in use in different parts of the
package at the same time. Very messy.

What I have hoped to achieve by some of the other features in the new
module importer is a way of achieving the same effect that packages
were generally being used for, ie., namespacing and encapsulation,
but still be able to support reloading. It does though mean  
restructuring
your imports a bit and it only becomes usable within the context of
mod_python, but then if it was some generic package which wasn't
mod_python specific to support a web application, one could question
why one would expect it to be reloadable anyway.

&gt;<i> This also implies that if a published module imports a package, and  
</I>&gt;<i> the published module is touched or modified, then the module will  
</I>&gt;<i> be reloaded, but not the package. Is this correct?
</I>
Correct, the file based handler module can be reloaded, but the package
will be referenced out of sys.modules where it already resides by the
Python __import__ builtin importer.

&gt;&gt;<i> BTW, that something outside of the document tree, possibly in  
</I>&gt;&gt;<i> sys.path,
</I>&gt;&gt;<i> is dealt with by Python __import__ doesn't mean you can't have module
</I>&gt;&gt;<i> reloading on stuff outside of the document tree. The idea is that  
</I>&gt;&gt;<i> if it is
</I>&gt;&gt;<i> part of the web application and needs to be reloadable, that it  
</I>&gt;&gt;<i> doesn't
</I>&gt;&gt;<i> really belong in standard Python directories anyway. People only  
</I>&gt;&gt;<i> install
</I>&gt;&gt;<i> it there at present because it is convenient.
</I>&gt;<i>
</I>&gt;<i> There are security benefits to not putting your code in the  
</I>&gt;<i> DocumentRoot. It's also useful to develop generic utilities that  
</I>&gt;<i> are used in multiple apps (not just mod_python), but that you don't  
</I>&gt;<i> want available globally on the system. I prefer extremely minimal  
</I>&gt;<i> frontends in the DocumentRoot, with most of my code stored  
</I>&gt;<i> elsewhere. Will the new importer support reloading modules outside  
</I>&gt;<i> of the DocumentRoot without putting them in sys.path?
</I>
If you don't want certain modules available globally on your system,  
ie.,
not in site-packages directory. You can obviously still set PythonPath
just within mod_python configuration so they are found without it
effecting command line Python. Obviously these are still notionally
on sys.path and so would not be candidates for reloading.

As I mentioned, setting of PythonPath currently has nasty side effect
preserved from current importer whereby it causes Directory directive
directory not to be searched. I want to get rid of this behaviour though
as it doesn't seem to make too much sense with new module importer.

   <A HREF="http://issues.apache.org/jira/browse/MODPYTHON-154">http://issues.apache.org/jira/browse/MODPYTHON-154</A>

although one still has to be careful in doing it as it may cause  
existing
applications to now incorrectly pick up a module from the Directory
directive directory when it wouldn't have before. Because of path
ordering issues in current importer, using common names in multiple
locations always caused unpredictable though.

Now in terms of modules which are a candidates for reloading being
able to be found on some search path, the first thing that could be done
(hasn't yet), is to allow for handler directives a path to be  
specified by:

   PythonHandlerPath '[&quot;/some/path1&quot;:&quot;/some/path2&quot;]'
   PythonHandler mydispatcher

The idea here is that where the specified handler module is not an
absolute or relative path, ie., is just a module name, the path defined
by PythonHandlerPath directive would be appended to the &quot;path&quot;
argument to apache.import_module() function call internally, the
current value of the &quot;path&quot; argument in this situation being the
Directory directive directory.

The order of search would then be, look in Directory directive  
directory,
then search PythonHandlerPath and then fall back to sys.path.

Note that this can be done now by virtue of a shell handler in the
document tree simply containing something like:

   from mod_python import apache
   _inner = apache.import_module(&quot;modname&quot;,path=[&quot;some/path1&quot;,&quot;/some/ 
path2&quot;])
   handler = _inner.handler

But then, it is probably better to use a full path name in the config
to begin with and more probably want I want to promote as a preferred
mechanism with the new importer. This is the main reason
why I haven't added PythonHandlerPath. That is, I think using an
absolute path name is better in being more precise.

The other reason PythonHandlerPath hasn't been implemented yet is that
the new importer is still optional and hasn't been properly embedded  
into
mod_python. Until it was accepted as the correct way to go, I didn't
want to be adding new directives or changing other parts of mod_python
which need to be changed so it works correctly in all situations. See:

   <A HREF="http://issues.apache.org/jira/browse/MODPYTHON-155">http://issues.apache.org/jira/browse/MODPYTHON-155</A>
   <A HREF="http://issues.apache.org/jira/browse/MODPYTHON-156">http://issues.apache.org/jira/browse/MODPYTHON-156</A>

for a couple of other examples of things which I haven't been able
to do yet and can't really until decision made to embed it properly.

So, PythonHandlerPath is one way that some special search path
could be consulted for reloadable modules. This though would only
apply by default to top level handler imports, it would not apply for
explicit calls to apache.import_module().

Overall I am a bit hesitant on introducing a directive which would
provide a search path which apache.import_module() would
automatically search. The reason is that like in the current importer
this can cause problems where different parts of the document tree
decide to set the search path differently.

For example, imagine a common set of modules outside of the
document tree which are used by code running under different
parts of the document tree and which therefore may have different
handler search paths defined. Depending on which part of the
document tree calls into the common code first will dictate how a
search may be done for some other module if the common modules
expect to find it on the search path. If one part of the document tree
doesn't include this other place, the search will fail. In other words
the common modules are relying on a search path that is in part out
of its control.

Hope you follow what I am getting at here. It is in some way the sort
of situation Dan had with the &quot;config&quot; module. His code was relying
on fact that directory his config module directory was in sys.path.
But PythonPath effectively being random order based on access
order when set to different things in different parts of the document
tree, if someone else provided a config module under same name
it would be found by mistake and he would not get the one he wanted.

My feeling is that those modules should be self contained, or if they do
need to search else where, that they should somehow define the search
path for the other module themselves, ie., using &quot;path&quot; argument to
the apache.import_module() method. This ensures they get want
they wanted.

So, an equivalent to PythonPath for reloadable modules could be
provided, but I'd only really wanted to do it when good use cases
shown and that it is also shown that unpredictable behaviour isn't
just going to result again because of how it could be set differently
in different parts of document tree. One would also have to come up
with a way to extend such a part inherited from a parent context. Ie.,
like how one can refer to sys.path in PythonPath now.

&gt;&gt;<i> The better way of dealing with this with the new module importer  
</I>&gt;&gt;<i> is to
</I>&gt;&gt;<i> put your web application modules elsewhere, ie., not on sys.path.  
</I>&gt;&gt;<i> You then
</I>&gt;&gt;<i> specify an absolute path to the actual .py file in the handler  
</I>&gt;&gt;<i> directive.
</I>&gt;&gt;<i>  &lt;Directory /&gt;
</I>&gt;&gt;<i>      SetHandler mod_python
</I>&gt;&gt;<i>      PythonHandler /path/to/web/application/PyServer/pserver.py
</I>&gt;&gt;<i>      ...
</I>&gt;<i>
</I>&gt;<i> How arbitrary is this path? Must it be within the DocumentRoot?
</I>
It is an absolute path relative to the root of the filesystem as a  
whole,
so can be anything you want. Can include drive specifiers on Win32.

There currently is a short cut that can be used to refer relative to the
directory the Directory directive refers to. This is:

   PythonHandler ~/mymodules/handler.py

Ie., &quot;~/&quot; prefix. As I mentioned in a previous email, wanting to get rid
of the &quot;~/&quot; prefix as a general mechanism. What I mean here is that
currently this can also be used in explicit calls to  
apache.import_module()
and will refer to the currently value of req.hlist.directory as root  
of path.
This leads to unpredictability with common modules like discussed
above and so getting rid of it. Instead, for handler directive case,  
will
instead allow:

   PythonHandler ./mymodules/handler.py

or:

   PythonHandler ../mymodules/handler.py

Ie., relative to directory the Directory directive specifies.

&gt;&gt;<i> Most cases I have seen is that people use packages purely to create a
</I>&gt;&gt;<i> namespace to group the modules. With the new module importer that
</I>&gt;&gt;<i> doesn't really need to be done anymore. That is because you can
</I>&gt;&gt;<i> directly reference an arbitrary module by its path. When you use the
</I>&gt;&gt;<i> &quot;import&quot; statement in files in that directory, one of the places  
</I>&gt;&gt;<i> it will
</I>&gt;&gt;<i> automatically look, without that directory needing to be in sys.path,
</I>&gt;&gt;<i> is the same directory the file is in. This achieves the same  
</I>&gt;&gt;<i> result as
</I>&gt;&gt;<i> what people are using packages for now but you can still have module
</I>&gt;&gt;<i> reloading work.
</I>&gt;<i>
</I>&gt;<i> Does it (the initial loading, not the reloading) also apply to  
</I>&gt;<i> packages in that directory? Or will it only work with standalone  
</I>&gt;<i> single file modules in the root of that directory?
</I>
Only works for standalone single file modules. A Python package  
always has
to be on sys.path and will never be reloabable by mod_python.

Note that if a package is very simple. Ie., is a single level and  
refers to
modules in the same package directly rather than through the root,  
using:

   package = apache.import_module(&quot;/some/path/package/__init__.py&quot;)

can often work though and will give you reloading as well.

&gt;<i> This is all very nifty, because it implies that a mod_python  
</I>&gt;<i> application can now be easily distributed by inflating a tarball  
</I>&gt;<i> and specifying the PythonHandler accordingly.
</I>
If PythonHandler path refers to the extracted tarball by absolute  
path, then
yes it becomes simpler as no need to mess with PythonPath or install  
it into
site-packages. You just can't implement it as a traditional package,  
but then
because it is self contained in its own directory which isn't  
mentioned in
sys.path, you still have the ability to internally structure it how  
you want.

&gt;<i> If the new importer works outside of the DocumentRoot,
</I>
Which it does, but then I probably don't need to confirm that again. :-)

&gt;<i> and Location is used instead of Directory, no files need to be  
</I>&gt;<i> created in the DocumentRoot at all. Or is this currently  
</I>&gt;<i> impossible, in regards to automatic module reloading? I already do  
</I>&gt;<i> this for some handlers I've written, and really like the  
</I>&gt;<i> flexibility provided by the virtualization.
</I>
Technically it is probably possible to have nothing at all in the  
document tree.
You can do this now with the current importer though, but means  
messing with
PythonPath with all the problems that entails and other code can pick  
up your
handler modules. By being able to specify an absolute path to your  
handler bundle
it becomes completely separate and would only be accessible by other  
code similarly
accessing it by absolute path.

I think perhaps you are starting to see where I am in part going with  
the new
module importer. That is that I am introducing this new way of being  
able to
refer to stuff by explicit paths, thereby breaking away from sys.path  
and all the
problems that result from that. It means restructuring stuff a bit  
and it will not be
backward compatible, but I think that overall it is a much better way  
of doing it
with better compartmentalisation and predictability.

Anyway, that was a long ramble. I really need to start getting some  
of this
documented properly, as there is certainly more to the new module  
importer
than providing an exact replacement for the old. I think the  
possibilities are
quite promising, but need to explain it well so people don't get the  
wrong idea
and that there are good reasons for doing it.

BTW, I forgot to say more about how the &quot;path&quot; argument to  
apache.import_module()
behaves when module name is referred to as an absolute or relative  
path. This
is something I started talking about in previous email to Dan. If you  
didn't
read that one, you may want to go back and look at it. I'll need to  
revisit that
one again, as that is the one area that probably still needs to be  
thought out
properly and changes still made to make it more usable.

Definitely getting late now, but then I slept most of the afternoon  
as felt a bit funny. :-)

Graham
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020965.html">[mod_python] The new module loader
</A></li>
	<LI>Next message: <A HREF="020936.html">[mod_python] The new module loader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20955">[ date ]</a>
              <a href="thread.html#20955">[ thread ]</a>
              <a href="subject.html#20955">[ subject ]</a>
              <a href="author.html#20955">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
