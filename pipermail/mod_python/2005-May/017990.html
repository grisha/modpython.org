<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] bug in apache.import_module
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20bug%20in%20apache.import_module&In-Reply-To=c298f2d705050223147e6c4c6%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017985.html">
   <LINK REL="Next"  HREF="017986.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] bug in apache.import_module</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Huzaifa Tapal</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20bug%20in%20apache.import_module&In-Reply-To=c298f2d705050223147e6c4c6%40mail.gmail.com"
       TITLE="[mod_python] bug in apache.import_module">huzaifa at hostway.com
       </A><BR>
    <I>Wed May  4 11:56:41 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="017985.html">[mod_python] bug in apache.import_module
</A></li>
        <LI>Next message: <A HREF="017986.html">[mod_python] How to stop PSP Page Cache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17990">[ date ]</a>
              <a href="thread.html#17990">[ thread ]</a>
              <a href="subject.html#17990">[ subject ]</a>
              <a href="author.html#17990">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Nicolas,

Your response was perfect!  Thanks a lot for that explaination and 
advice.  I wouldn't be able to encapsulate the path variable since the 
path is dynamic and is based off of the URI which provides the path to 
the page to be executed.  However, your information has given me a very 
good understanding on programming in multi-threaded environment. 

I will definitely, look into the book you have suggested.

Thanks again for all of your help.  Sorry to be a pain :-(

Huzaifa

Nicolas Lehuen wrote:

&gt;<i>Huzaifa,
</I>&gt;<i>
</I>&gt;<i>You're right in thinking that the same method will be accessed at the
</I>&gt;<i>same time, but wrong in thinking that there is a risk that a thread
</I>&gt;<i>messes with another thread's stack.
</I>&gt;<i>
</I>&gt;<i>Multi-threading is perfectly predictable and safe on this level : you
</I>&gt;<i>can launch as many threads as you want running the same
</I>&gt;<i>function/method, each thread will execute in its own environment, each
</I>&gt;<i>one will get its own stack, therefore each one will have its own set
</I>&gt;<i>of local variables (including parameters) when the method will be
</I>&gt;<i>executed. There is absolutely no risk that changing a local parameter
</I>&gt;<i>in one thread messes with a local parameter in another thread.
</I>&gt;<i>
</I>&gt;<i>You only have to worry about synchronization when multiple thread
</I>&gt;<i>share some data ; for example, for a bound method (a method which is
</I>&gt;<i>applied to a specific object instance), even if the threads stacks are
</I>&gt;<i>perfectly isolated, the multiple threads will target the same object
</I>&gt;<i>instance, and therefore one must think about synchronisation issues
</I>&gt;<i>when accessing the members of the object.
</I>&gt;<i>
</I>&gt;<i>To go back to your fix_path() example, only local variables are
</I>&gt;<i>changed in the function. The local &quot;path&quot; variable changes, but not
</I>&gt;<i>the list passed as a parameter. This means the code would be perfectly
</I>&gt;<i>thread-safe even with the locking code removed.
</I>&gt;<i>
</I>&gt;<i>Still, you will tell me, there is the possibility that someone changes
</I>&gt;<i>the shared path while I'm trying to fix it. Then, change your design.
</I>&gt;<i>At the minimum, you should place your locking code where it is needed,
</I>&gt;<i>not in the lowest common factor point.
</I>&gt;<i>
</I>&gt;<i>The one you chose is pretty bad (sorry to be harsh ;-) : imagine you
</I>&gt;<i>want to call fix_path for each request. Bam, for each request, you'll
</I>&gt;<i>hold a global lock just for fixing a path variable ! You'll reduce the
</I>&gt;<i>server performance just for housekeeping issues...
</I>&gt;<i>
</I>&gt;<i>Putting some code where it is needed is what OOP was made for (well,
</I>&gt;<i>it was made for making it easier, at least). What I'm suggesting is to
</I>&gt;<i>encapsulate the shared path variable in an object, and fix it each
</I>&gt;<i>time it is modified, not each time it is accessed. Then, you can use
</I>&gt;<i>whatever locking scheme you need to ensure the consistency of this
</I>&gt;<i>shared path variable.
</I>&gt;<i>
</I>&gt;<i>Also, locking is not the only option for this : you can also copy the
</I>&gt;<i>path list and use a copy in the thread, instead of the original ; you
</I>&gt;<i>won't have to worry about the original list being modified, since each
</I>&gt;<i>thread will have its own copy.
</I>&gt;<i>
</I>&gt;<i>There are many, many design choices to be made when build a
</I>&gt;<i>multi-threaded architecture. One thing is sure : you can't assume the
</I>&gt;<i>worst in each part of the architecture. You have to have places (like
</I>&gt;<i>this utility method) where you can safely assume that the parameters
</I>&gt;<i>you are given won't be modified during the call.
</I>&gt;<i>
</I>&gt;<i>Multi-threading is not about locking everything, not at all, because
</I>&gt;<i>we might as well run in a single thread, the performances would be
</I>&gt;<i>better. It's about putting the right locks at the right place,
</I>&gt;<i>sometimes choosing to copy data instead of sharing it.
</I>&gt;<i>
</I>&gt;<i>Sorry to be so vague, but to go further, I'd need to go deeper in your
</I>&gt;<i>code, and this I have not enough time to do :).
</I>&gt;<i>
</I>&gt;<i>A very good book about multithreading is &quot;Concurrent Programming in
</I>&gt;<i>Java&quot; from Doug Lea. It's about Java and also quite old but a lot of
</I>&gt;<i>information can be applied to any multi-threading problem.
</I>&gt;<i>
</I>&gt;<i><A HREF="http://www.amazon.com/exec/obidos/tg/detail/-/0201310090/">http://www.amazon.com/exec/obidos/tg/detail/-/0201310090/</A>
</I>&gt;<i>
</I>&gt;<i>Regards,
</I>&gt;<i>Nicolas
</I>&gt;<i>
</I>&gt;<i>2005/5/3, Huzaifa Tapal &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">huzaifa at hostway.com</A>&gt;:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i> Hello Nicolas,
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> What I am really worried about is that in a multi-threaded environment,
</I>&gt;&gt;<i>accessing a modular level method, multiple threads might be accessing the
</I>&gt;&gt;<i>same method at the same time and overwriting the other threads path list as
</I>&gt;&gt;<i>a result.  
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> As per your question, I create a _lock object on top of the module.  Pretty
</I>&gt;&gt;<i>much this method was created in a &quot;SharedResources&quot; module as a modular
</I>&gt;&gt;<i>level method.  My framework then imports the method and uses it within to
</I>&gt;&gt;<i>fix the paths.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> What do you think?
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Hozi
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Nicolas Lehuen wrote: 
</I>&gt;&gt;<i> Hi Huzaifa,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Well, that's really up to you, especially since I don't understand
</I>&gt;&gt;<i>where the _lock variable comes from.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>If it's not possible to change the path list which is passed as a
</I>&gt;&gt;<i>parameter without acquiring the lock, then why not, but I'd put the
</I>&gt;&gt;<i>locking mechanism in the calling code rather than in this function.
</I>&gt;&gt;<i>Note that you are not modifying the path list in-place : you just
</I>&gt;&gt;<i>return a copy of the path list with some fixes in it. So there is no
</I>&gt;&gt;<i>need to lock anything here, except if you fear that the path list will
</I>&gt;&gt;<i>be changed during the iteration, but for that, you have to put a
</I>&gt;&gt;<i>locking mechanism somewhere else for any modification of the path
</I>&gt;&gt;<i>list. So my first advice is : keep all locking code in the same place
</I>&gt;&gt;<i>and you'll save time and mental health :).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>My second advice is : don't be over-protective at the cost of
</I>&gt;&gt;<i>performance. Trust the users of your code. Provided that they have a
</I>&gt;&gt;<i>proper documentation, it's not necessary to lock anything, because
</I>&gt;&gt;<i>your users will know that bad things will happen if they change the
</I>&gt;&gt;<i>path list during iteration, so they'll do the right stuff accordingly.
</I>&gt;&gt;<i>Likewise, it's not necessary to check whether path is a list, or
</I>&gt;&gt;<i>whether some path entries are None or &quot;&quot;. If your users want to give
</I>&gt;&gt;<i>silly data to your function, let them do it, and let Python throw
</I>&gt;&gt;<i>exceptions at them.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Regards,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Nicolas
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>On 4/29/05, Huzaifa Tapal &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">huzaifa at hostway.com</A>&gt; wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I wanted to ask for a piece of advise. So the fix that I have mentioned, I
</I>&gt;&gt;<i>moved that fix (the method I replaced with the map(lambda) solution you had
</I>&gt;&gt;<i>with a minor fix) to another &quot;SharedResources&quot; module that I import in my
</I>&gt;&gt;<i>framework's handler. From within the handler and my app, I am call that
</I>&gt;&gt;<i>method passing in a path argument that it *fixes* and returns back the
</I>&gt;&gt;<i>results. Here is what the new method looks like:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> def fix_paths( path ):
</I>&gt;&gt;<i> &quot;&quot;&quot; Convenience method for checking and 
</I>&gt;&gt;<i> adding '/' to the end of paths for compatibility
</I>&gt;&gt;<i> with mod_python's import_module. &quot;&quot;&quot;
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> _lock.acquire()
</I>&gt;&gt;<i> try:
</I>&gt;&gt;<i> if path and type(path) == type([]):
</I>&gt;&gt;<i> path = map(lambda entry : (entry!='' and entry[-1]!='/' and
</I>&gt;&gt;<i>entry+'/') or entry,path)
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> return path
</I>&gt;&gt;<i> finally:
</I>&gt;&gt;<i> _lock.release()
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Should I have the thread-locking in place or can I get by without having it
</I>&gt;&gt;<i>in place? The reason I did add that was because the path value may get
</I>&gt;&gt;<i>changed, in the process, I thought of making this method thread-safe.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Also Nicolas, if you notice I added another check in your lambda function
</I>&gt;&gt;<i>to check if the entry is an empty string. If that wasn't there then if an
</I>&gt;&gt;<i>empty string path was passed in the list paths, the function would break. 
</I>&gt;&gt;<i>Thought, i'd let you know if you were gonna add this functionality into the
</I>&gt;&gt;<i>import_module method for apache.py
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Thanks
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Hozi
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Nicolas Lehuen wrote: 
</I>&gt;&gt;<i> Sorry, reposting to the whole list :
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>The change I've made for MODPYTHON-9 affects only the publisher
</I>&gt;&gt;<i>module. It solves the problem encountered when you had two pages, one
</I>&gt;&gt;<i>at /index.py, and the other at /foobar/index.py.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Huzaifa, what I don't understand here is whether moduleA has the same
</I>&gt;&gt;<i>name as moduleB, and whether you are using mod_python.publisher or
</I>&gt;&gt;<i>not.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>If you use the publisher, your problem has been solved in the latest
</I>&gt;&gt;<i>development version, and the fix will be in the next release.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Anyway, if we put aside the fix specific to the publisher, the problem
</I>&gt;&gt;<i>you describe is real, and the workaround you provide is correct.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>It is so correct that the only way I see of fixing that is to
</I>&gt;&gt;<i>integrate the workaround in the import_module function, that is to say
</I>&gt;&gt;<i>to check whether each path component passed in the path list argument
</I>&gt;&gt;<i>ends with a '/' (or '\'), and if not, add a '/' (or '\\'). This is
</I>&gt;&gt;<i>done easily in the first line of the function :
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>if path:
</I>&gt;&gt;<i> path = map(lambda entry : (entry[-1]!='/' and entry+'/') or entry,path)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>However, there is no easy way of telling what directory separator
</I>&gt;&gt;<i>should be used ; theoretically, os.sep gives us the correct directory
</I>&gt;&gt;<i>separator, but even under Win32 Apache admins are advised to use &quot;/&quot;
</I>&gt;&gt;<i>which is compatible (at the OS level). So, we might as well always use
</I>&gt;&gt;<i>&quot;/&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>What I fear is that adding all these checks to import_module will make
</I>&gt;&gt;<i>it a little bit too slow, so what about adding a line or two in the
</I>&gt;&gt;<i>documentation about the fact that all directories mentioned in the
</I>&gt;&gt;<i>path argument should end with a '/' ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Regards,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Nicolas
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>On 4/29/05, Graham Dumpleton &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">grahamd at dscpl.com.au</A>&gt; wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Nicolas, does the change you have already made for MODPYTHON-9
</I>&gt;&gt;<i>also address this slightly different variation on the problem?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Original report was based on same name module in parent and child
</I>&gt;&gt;<i>subdirectories, not sibling directories which share a common prefix
</I>&gt;&gt;<i>to the subdirectory name.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Graham
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Huzaifa Tapal wrote ..
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> For my fix, I patched this issue by passing the import_module function
</I>&gt;&gt;<i>the path with &quot;/&quot; in the end. That way it distinguishes from
</I>&gt;&gt;<i>/home/user/dir1 and /home/user/dir123
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>hozi
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Graham Dumpleton wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> See:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> <A HREF="http://issues.apache.org/jira/browse/MODPYTHON-9">http://issues.apache.org/jira/browse/MODPYTHON-9</A>
</I>&gt;&gt;<i> <A HREF="http://issues.apache.org/jira/browse/MODPYTHON-10">http://issues.apache.org/jira/browse/MODPYTHON-10</A>
</I>&gt;&gt;<i> <A HREF="http://issues.apache.org/jira/browse/MODPYTHON-11">http://issues.apache.org/jira/browse/MODPYTHON-11</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>There are various known issues with using same name module in different
</I>&gt;&gt;<i>directories.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>The first one has been addressed for next version of mod_python.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Graham
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>On 29/04/2005, at 8:22 AM, Huzaifa Tapal wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I think there is a bug in apache.import_module. I am using
</I>&gt;&gt;<i>apache.import_module passing in the path where I want the module
</I>&gt;&gt;<i>imported from. I am seeing a very odd result as to sometimes, the
</I>&gt;&gt;<i>module that is loaded is not the right one. Instead it loads a
</I>&gt;&gt;<i>module that is of the same name but in a different directory. Here
</I>&gt;&gt;<i>is what is happening:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I have two modules of same name in 2 different directories as follows;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>/home/user/dir1/moduleA
</I>&gt;&gt;<i>/home/user/dir123/moduleB
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Lets say I restart apache and load up moduleA. At that point there
</I>&gt;&gt;<i>is an entry in sys.modules for moduleA. Lets say then, I load up
</I>&gt;&gt;<i>moduleB, now the original entry for moduleA is overwritten by this
</I>&gt;&gt;<i>new entry. Now when I go back to load moduleA, I get back moduleB
</I>&gt;&gt;<i>results. Here is why:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>In apache.import_module if I pass in the path to load moduleA from
</I>&gt;&gt;<i>'/home/user/dir1' and the last module was in '/home/user/dir123' then
</I>&gt;&gt;<i>the check in import_module to make sure both modules aren't the same
</I>&gt;&gt;<i>fails since it does a &quot;file.startswith()&quot; check on the path. Since
</I>&gt;&gt;<i>the path moduleA is in the path to moduleB, it loads the wrong module.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I see that somebody else had complained about this problem in
</I>&gt;&gt;<i>mod_python 1.3.1 but it still has not been patched.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Any ideas?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Hozi
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>_______________________________________________
</I>&gt;&gt;<i>Mod_python mailing list
</I>&gt;&gt;<i><A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;&gt;<i><A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i>Mod_python mailing list
</I>&gt;&gt;<i><A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;&gt;<i><A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i>Mod_python mailing list
</I>&gt;&gt;<i><A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;&gt;<i><A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://mm_cfg_has_not_been_edited_to_set_host_domains/pipermail/mod_python/attachments/20050504/a8eb4e18/attachment-0001.html">http://mm_cfg_has_not_been_edited_to_set_host_domains/pipermail/mod_python/attachments/20050504/a8eb4e18/attachment-0001.html</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017985.html">[mod_python] bug in apache.import_module
</A></li>
	<LI>Next message: <A HREF="017986.html">[mod_python] How to stop PSP Page Cache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17990">[ date ]</a>
              <a href="thread.html#17990">[ thread ]</a>
              <a href="subject.html#17990">[ subject ]</a>
              <a href="author.html#17990">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
