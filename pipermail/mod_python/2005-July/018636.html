<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Articles on module importing.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Articles%20on%20module%20importing.&In-Reply-To=1120798746.19962%40dscpl.user.openhosting.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018634.html">
   <LINK REL="Next"  HREF="018638.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Articles on module importing.</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Jorey Bump</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Articles%20on%20module%20importing.&In-Reply-To=1120798746.19962%40dscpl.user.openhosting.com"
       TITLE="[mod_python] Articles on module importing.">list at joreybump.com
       </A><BR>
    <I>Fri Jul  8 09:40:23 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="018634.html">[mod_python] Articles on module importing.
</A></li>
        <LI>Next message: <A HREF="018638.html">[mod_python] Articles on module importing.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18636">[ date ]</a>
              <a href="thread.html#18636">[ thread ]</a>
              <a href="subject.html#18636">[ subject ]</a>
              <a href="author.html#18636">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Graham Dumpleton wrote:
&gt;<i> Jorey Bump wrote ..
</I>&gt;<i> 
</I>&gt;&gt;<i>Understood. My point is that alternate import mechanisms such as 
</I>&gt;&gt;<i>import_module() shouldn't be encouraged in *published* modules or 
</I>&gt;&gt;<i>modules that are based on other handlers. I think we both agree that we
</I>&gt;&gt;<i>want the average Python programmer to be able to start using mod_python
</I>&gt;&gt;<i>  as seamlessly as possible. 
</I>&gt;<i> 
</I>&gt;<i> What would you think of a scheme whereby you could use the &quot;import&quot;
</I>&gt;<i> statement and underneath it would magically and seamlessly translate
</I>&gt;<i> that into a call to import_module() for you?
</I>&gt;<i> 
</I>&gt;<i> The call to import_module() under the covers would only happen though where
</I>&gt;<i> the module was in the same directory, or in one of a set of special directories
</I>&gt;<i> designated by a path distinct from sys.path. If a module wasn't found in
</I>&gt;<i> those places, it will fall back to use of the standard Python import
</I>&gt;<i> mechanism and search in only sys.path.
</I>
Yes, this is precisely what I'm trying to describe.

&gt;<i> Thus, for those modules local to the document tree or in specially
</I>&gt;<i> designated directories, even though the &quot;import&quot; statement was used,
</I>&gt;<i> automatic module reloading would work. Because the &quot;import&quot;
</I>&gt;<i> statement is used, you don't need to have two sets of code, one for
</I>&gt;<i> command line use and one for use under mod_python. Under mod_python,
</I>&gt;<i> if necessary, all you would need to do is designate those special directories
</I>&gt;<i> where modules are stored which you want managed by &quot;import_module()&quot;
</I>&gt;<i> under the covers instead of the standard Python module import mechanism.
</I>
Exactly. But there could also be a default (i.e. &quot;.htPython&quot;), to 
provide some commonality among installations, to ease configuration for 
both the developer and administrator.

&gt;&gt;<i>After editing modules 
</I>&gt;&gt;<i>imported by a published module, apache must be restarted.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Or all the modules that inherit it need to be touched so there modification
</I>&gt;<i> time changes. :-)
</I>
Yes, perhaps I overemphasized, but I find such workarounds to be 
tedious, also (&quot;OK, I edited a module, now what other files do I need to 
touch?&quot;. The holy grail here is behaviour similar to PHP, where file 
edits take immediate effect, but without losing the performance gains 
from module caching, whenever possible.

&gt;&gt;<i>No. I think it's poor practice to put any kind of library files in a 
</I>&gt;&gt;<i>directory that is accessible to browsers, even with other languages. The
</I>&gt;&gt;<i>risk is too high that someone with knowledge of your directory structure
</I>&gt;&gt;<i>can call your support modules directly, causing unintended side effects.
</I>&gt;<i> 
</I>&gt;<i> It could be viewed as being not recommended for beginners who don't
</I>&gt;<i> understand all the security implications, but it is possible now and when
</I>&gt;<i> someone who knows how to secure the system properly does it, it can
</I>&gt;<i> be quick means to and end and can save a lot of pain in other ways.
</I>
Absolutely. I wouldn't want to prevent it, but I still think it's a bad 
idea.

&gt;<i> Thus, whether one does this or not is going to be a convention only.
</I>
Correct.

&gt;<i> Depending on what type of handler system you are using, putting such
</I>&gt;<i> common code in modules starting with an underscore and using some
</I>&gt;<i> thing like the following in a .htaccess file:
</I>&gt;<i> 
</I>&gt;<i>   &lt;Files &quot;_*&quot;&gt;
</I>&gt;<i>   deny from all
</I>&gt;<i>   &lt;/Files&gt;
</I>&gt;<i> 
</I>&gt;<i> can be enough to stop the code being exposed.
</I>
Yes, but here we're getting into one of the current weaknesses of 
mod_python: It requires too much administrative capability.

What's needed is a handler that's included in the mod_python 
distribution that allows an admin to install and configure mod_python 
once, and developers to use it immediately for web applications, with 
many of the associated headaches taken care of behind the scenes. 
Publisher2, perhaps. :)

&gt;&gt;<i>I  don't want to see mod_python automagically package subdirectories or add
</I>&gt;&gt;<i>them to the path because it gives newbies more rope to hang themselves.
</I>&gt;<i> 
</I>&gt;<i> What if the scheme didn't actually involve the addition of either the top level
</I>&gt;<i> handler directory or the subdirectories into sys.path in the first place for this
</I>&gt;<i> to work?
</I>
Yes, a virtualization may be necessary, especially when trying to 
prevent collisions. But when taken out of the mod_python environment, 
the code should still work (although one may have to prefix the special 
directory to PYTHONPATH or move the modules into the search path).

&gt;<i> The problem we get at the moment is that we get questions of why this sort
</I>&gt;<i> of importing doesn't work for subdirectories in the first place. How only the
</I>&gt;<i> top level handler directory is added into sys.path is explained. End result is
</I>&gt;<i> that they go and fiddle with PythonPath explicitly anyway and still hang
</I>&gt;<i> themselves.
</I>
I hesitate to mention it, but maybe the directory in which the 
PythonHandler is defined could also have the special quality where the 
modules in .htPython are available to all other modules in the 
interpreter, regardless of location. Actually, this is easily done now, 
without any changes to mod_python. Simply define this in a virtual host:

DocumentRoot /var/www/host1/site

&lt;LocationMatch &quot;.htPython&quot;&gt;
   Deny from All
&lt;/LocationMatch&gt;

&lt;Directory /var/www/host1/site/app&gt;
   SetHandler python-program
   PythonHandler mod_python.publisher
   PythonDebug On
   PythonPath &quot;['/var/www/host1/site/app/.htPython'] + sys.path&quot;
&lt;/Directory&gt;

An admin could do this now, making it much easier to support 
mod_python.publisher on a server for multiple clients. One advantage is 
that a team of developers would have a common area to store custom 
modules for import, and they would at least be able to avoid name 
collisions for these modules (if not the published modules).

A little protection is offered by denying browser access to the 
.htPython directory, but it should noted that any other system user can 
read those files. This is a problem shared by most web applications, not 
just those written for mod_python, even when the files are stored 
outside of the DocumentRoot.

This also eases application distribution, but it's not as simple as 
tarballing a single directory.

&gt;<i> Wouldn't it be preferable if a scheme could be offered where &quot;import&quot; just
</I>&gt;<i> works for modules in the same directory regardless of whether the importer is
</I>&gt;<i> in the top level handler directory or a subdirectory, especially where the
</I>&gt;<i> manner it was implemented didn't require extension of sys.path and where
</I>&gt;<i> automatic module reloading worked?
</I>
Yes, but I fear that it encourages bad practice in the web application 
sphere. And it will cause problems exactly because it's perfectly 
acceptable, even desirable, in other application domains. In some ways, 
it's best to treat a module accessible by a browser as a simple frontend 
to a backend application; an interface, if you will. You don't encounter 
this problem at all if your standalone application includes a web server 
and is proxied through apache, for example.

&gt;<i> I feel it comes down to looking at how all users want and expect this stuff
</I>&gt;<i> to work, rather than drawing conclusions as to whether one way is better
</I>&gt;<i> than another, and make it work, but make it work transparently in what
</I>&gt;<i> would be regarded as correct way for the mod_python case.
</I>
Well, the customer isn't always right -- mod_python is never going to be 
the same as PHP (I hope!). Some of the shock to new users is a result of 
their experience with other languages, so they will need to learn new 
tricks. But even for experienced Python programmers, some annoyances 
remain. I'd like to address these, first.

&gt;<i> Unless you take extra precautions by adding &quot;deny from all&quot; into the
</I>&gt;<i> &quot;.htPython/.htaccess&quot; file, these modules are still going to be accessible.
</I>&gt;<i> That you have to take explicit steps to protect them is not much
</I>&gt;<i> different to using a convention of using a leading underscore.
</I>
Yes, you're right. I mistakenly assumed that the default config of most 
apache installations forbids access to any resource that begins with 
&quot;.ht&quot;, but this actually only applies to files, so some administrative 
step must be taken. Although it would be a good idea for mod_python 
itself to prevent access, it must also be handled by apache, in case 
mod_python isn't running. Since it's in the DocumentRoot, it's important 
not to leak information. In any case, using a special directory is more 
explicit (and flexible) than a file naming convention, IMHO.

&gt;<i> If the &quot;import&quot; statement overlays &quot;import_module()&quot; and the later supports
</I>&gt;<i> the same named module in different directories, you wouldn't have to
</I>&gt;<i> worry about collisions. If it knows to grab them from this directory using
</I>&gt;<i> this mechanism before looking elsewhere through some special path
</I>&gt;<i> designation, then you could have everything you want and more.
</I>&gt;<i> 
</I>&gt;<i> Am getting into implementation, which I did't want to, but what if for
</I>&gt;<i> this to work one way was to add the following to the start of your
</I>&gt;<i> appl1.py file:
</I>&gt;<i> 
</I>&gt;<i>   import os
</I>&gt;<i> 
</I>&gt;<i>   directory = os.path.dirname(__file__)
</I>&gt;<i>   modules = os.path.join(directory,&quot;.htPython&quot;)
</I>&gt;<i>   __path__.insert(0,modules)
</I>&gt;<i> 
</I>&gt;<i>   import module1
</I>&gt;<i>   import module2
</I>&gt;<i> 
</I>&gt;<i> You need to add a few lines, but it gives you control on where &quot;import&quot;
</I>&gt;<i> looks, but through a bit of magic when it finds &quot;module1&quot; existant in
</I>&gt;<i> that directory it will also use &quot;import_module()&quot; to actually load it and
</I>&gt;<i> when it handles same named modules the collision problems go away.
</I>
Yes, but I wouldn't want to ask a developer to do this in a published 
module. It's too much of a &quot;gotcha&quot;.

&gt;<i> It isn't that a specifying a special location is important, but that there is
</I>&gt;<i> a separation between sys.path modules where standard Python import
</I>&gt;<i> infrastructure is used, and web application directories where under the
</I>&gt;<i> covers of &quot;import&quot; the &quot;import_module()&quot; function is used. Thus with the
</I>&gt;<i> example above, a mechanism is provided to specify where you directory
</I>&gt;<i> is, but you set your own convention as to what it is named and where
</I>&gt;<i> it is located.
</I>
Yes, but I think it's important to handle this outside of the published 
module, in the handler, even if the standard import mechanism is only 
being enhanced or simulated. Too much special code in the published 
module makes it proprietary to mod_python, in which case, you might as 
well use a full blown framework.

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018634.html">[mod_python] Articles on module importing.
</A></li>
	<LI>Next message: <A HREF="018638.html">[mod_python] Articles on module importing.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18636">[ date ]</a>
              <a href="thread.html#18636">[ thread ]</a>
              <a href="subject.html#18636">[ subject ]</a>
              <a href="author.html#18636">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
