<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Very odd behavior using mysqldb
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Very%20odd%20behavior%20using%20mysqldb&In-Reply-To=450C3819.4070600%40jgassociates.ca">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022084.html">
   <LINK REL="Next"  HREF="022090.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Very odd behavior using mysqldb</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Very%20odd%20behavior%20using%20mysqldb&In-Reply-To=450C3819.4070600%40jgassociates.ca"
       TITLE="[mod_python] Very odd behavior using mysqldb">grahamd at dscpl.com.au
       </A><BR>
    <I>Sat Sep 16 18:17:31 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022084.html">[mod_python] Very odd behavior using mysqldb
</A></li>
        <LI>Next message: <A HREF="022090.html">[mod_python] Very odd behavior using mysqldb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22088">[ date ]</a>
              <a href="thread.html#22088">[ thread ]</a>
              <a href="subject.html#22088">[ subject ]</a>
              <a href="author.html#22088">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>In addition to what Jim has says, having the database connection created
at global module scope of a handler code file isn't necessarily a  
good idea.
The problem here is if automatic module reloading is on and you make  
changes
to your handler file over time. What will happen is that when the  
handler code
file is reloaded, your existing database connection objects will be  
discarded
and reinitialised. If normal object cleanup doesn't result in the  
database
handles being cleaned up properly, you can get a leak in database  
resource
handles and eventually you will run out of connections to the database.

For details on issues like this and others which will affect you with  
the version
of mod_python you are running, check out:

   <A HREF="http://www.dscpl.com.au/wiki/ModPython/Articles/">http://www.dscpl.com.au/wiki/ModPython/Articles/</A> 
TheProcessInterpreterModel
   <A HREF="http://www.dscpl.com.au/wiki/ModPython/Articles/">http://www.dscpl.com.au/wiki/ModPython/Articles/</A> 
ModuleImportingIsBroken

Graham

On 17/09/2006, at 3:44 AM, Jim Gallacher wrote:

&gt;<i> Eric Brunson wrote:
</I>&gt;&gt;<i> I've been working on a project using mod_python to access a mysql  
</I>&gt;&gt;<i> database using the MySQLdb API.  I know mod_python is still  
</I>&gt;&gt;<i> considered beta under Apache 2, so I thought I'd bring an issue to  
</I>&gt;&gt;<i> the attention of the list.
</I>&gt;&gt;<i> I was seeing some very bizarre results when generating dynamic  
</I>&gt;&gt;<i> content from the database, which I first attributed to PSP  
</I>&gt;&gt;<i> caching, but then investigated further when I switched to using  
</I>&gt;&gt;<i> the publisher handler.  It may be the way I've set up my modules  
</I>&gt;&gt;<i> and database connections, but I haven't convinced myself that I  
</I>&gt;&gt;<i> really understand the problem and until I do, I'm not going to be  
</I>&gt;&gt;<i> happy about it.  I have found a workaround that I can live with,  
</I>&gt;&gt;<i> but I don't really like it that much because it requires  
</I>&gt;&gt;<i> constantly connecting to and disconnection from the database.
</I>&gt;&gt;<i> The problem was simply getting old, wrong results interleaved with  
</I>&gt;&gt;<i> new, correct results after updating the database.  Simply put, I'm  
</I>&gt;&gt;<i> displaying data from a table.  My index.py imports a module for  
</I>&gt;&gt;<i> generating HTML which, in turn, includes a module for doing  
</I>&gt;&gt;<i> database access.  The odd thing about how I set up the database  
</I>&gt;&gt;<i> access, and I think it's pertinent to the problem, was that I  
</I>&gt;&gt;<i> automatically connect to the database when I import the database  
</I>&gt;&gt;<i> module.  Like this:
</I>&gt;&gt;<i> ----- database.py -----
</I>&gt;&gt;<i> import MySQLdb
</I>&gt;&gt;<i> from mod_python import apache
</I>&gt;&gt;<i> def Connect():
</I>&gt;&gt;<i>    return MySQLdb.connect( '<A HREF="mysql://me:pass@localhost/mydatabase'">mysql://me:pass@localhost/mydatabase'</A> )
</I>&gt;&gt;<i> dbc = Connect()
</I>&gt;&gt;<i> def someExampleAccessFunction():
</I>&gt;&gt;<i>    global dbc
</I>&gt;&gt;<i>    curs = dbc.cursor()
</I>&gt;&gt;<i>    curs.execute( &quot;select count(0) from sometable&quot; )
</I>&gt;&gt;<i>    result = curs.fetchall()[0][0]
</I>&gt;&gt;<i>    curs.close()
</I>&gt;&gt;<i>    apache.log_error( &quot;result was %s&quot; % result )
</I>&gt;&gt;<i>    return result
</I>&gt;&gt;<i> ----- end database.py -----
</I>&gt;&gt;<i> Let's disregard whether that's good programming practice or not,  
</I>&gt;&gt;<i> the fact is, I could query that value several times by doing a  
</I>&gt;&gt;<i> page reload, then delete a record from the database and commit the  
</I>&gt;&gt;<i> change, then subsequent page loads would interleave old results  
</I>&gt;&gt;<i> with new results, seemingly cyclically.
</I>&gt;&gt;<i> The key to my confusion is that the error logs for apache would  
</I>&gt;&gt;<i> show a message for every page reload, and the result from the  
</I>&gt;&gt;<i> query would agree with whatever data was displayed on the page,  
</I>&gt;&gt;<i> correct or incorrect.  Meanwhile a direct query to the database  
</I>&gt;&gt;<i> from the command line would always return the correct result from  
</I>&gt;&gt;<i> the database.
</I>&gt;&gt;<i> My best guess so far is that multiple threads in apache get  
</I>&gt;&gt;<i> multiple copies of mod_python, each with it's own copy of the  
</I>&gt;&gt;<i> imported database module in memory and each module maintaining a  
</I>&gt;&gt;<i> different database connection that is somehow caching results.   
</I>&gt;&gt;<i> I've never seen this behavior in any application until I tried  
</I>&gt;&gt;<i> this under mod_python.  I was able to force the correct results to  
</I>&gt;&gt;<i> always be returned by getting rid of the module variable, dbc, and  
</I>&gt;&gt;<i> moving the mysqldb.connect() call to inside each function call,  
</I>&gt;&gt;<i> opening the database connection, executing my sql, then closing  
</I>&gt;&gt;<i> the database connection.  This is less than optimal, since I may  
</I>&gt;&gt;<i> make several database queries during each page load, so later  
</I>&gt;&gt;<i> today I'll try making the database connection in the index.py,  
</I>&gt;&gt;<i> then passing the connection handle to each of the calls that need  
</I>&gt;&gt;<i> it.  Also a little less than optimal, but tolerable.
</I>&gt;&gt;<i> Does anyone have any insight into this behavior?  It's more of an  
</I>&gt;&gt;<i> academic question at this point, but I wonder if it may lead to an  
</I>&gt;&gt;<i> improvement if we were able to identify the problem and implement  
</I>&gt;&gt;<i> a transparent fix.  Also, feel free to let me know if I'm  
</I>&gt;&gt;<i> completely offbase with my theory of what's going on under the hood.
</I>&gt;<i>
</I>&gt;<i> Your assessment with respect to having multiple copies of  
</I>&gt;<i> mod_python, each with its own copy of the imported modules and data  
</I>&gt;<i> is correct. It is not a bug but rather the way apache works.  
</I>&gt;<i> Depending on which apache-mpm you are using (either prefork or  
</I>&gt;<i> worker on Fedora) and your configuration, you may have anywhere  
</I>&gt;<i> from a few, to dozens of independent child processes. Indeed if you  
</I>&gt;<i> are using the prefork mpm on a heavily loaded server you could have  
</I>&gt;<i> hundreds of processes. In such cases using a persistent db  
</I>&gt;<i> connection will likely cause problems with exhausting the number of  
</I>&gt;<i> available mysql connections. Persistent connections in such a  
</I>&gt;<i> scenario are discouraged in general - not just in mod_python.
</I>&gt;<i>
</I>&gt;<i> As to your particular problem, I wonder if you are using  
</I>&gt;<i> transactions, but are not committing immediately after an update?  
</I>&gt;<i> The process which apache chooses to to handle a request is random.  
</I>&gt;<i> Say for example you update in process A without a commit. The next  
</I>&gt;<i> request may be handled by  another process, which will see the old  
</I>&gt;<i> data. A subsequent request may then come in but be handled by  
</I>&gt;<i> process A again, which will see the new data since it is using the  
</I>&gt;<i> same connection as that used for the update. Thus you will get the  
</I>&gt;<i> interleaving effect.
</I>&gt;<i>
</I>&gt;<i> This is not unique to db connections. Don't be fooled into thinking  
</I>&gt;<i> that module-level attributes are global across your application as  
</I>&gt;<i> they are not. In anything other than winnt-mpm (which is a single,  
</I>&gt;<i> threaded process), you will have multiple, independent copies of  
</I>&gt;<i> that variable.
</I>&gt;<i>
</I>&gt;<i> Opening and closing your db connection for each request is the  
</I>&gt;<i> usual solution, as you've discovered. It is possible to do  
</I>&gt;<i> connection pooling, but you need to be a little smarter about it  
</I>&gt;<i> ensure you don't run into problems or exhaust the number of mysql  
</I>&gt;<i> connections configured. Don't forget that leaving open a connection  
</I>&gt;<i> consumes memory resources as well.
</I>&gt;<i>
</I>&gt;<i> This is not to say that you need to open and close the connection  
</I>&gt;<i> each time you want to access the database within a request. The  
</I>&gt;<i> usual method is to stuff your db connection into the request object  
</I>&gt;<i> itself. For example:
</I>&gt;<i>
</I>&gt;<i> def handler(req):
</I>&gt;<i>     req.db = MySQLdb.connect( '<A HREF="mysql://me:pass@localhost/mydatabase'">mysql://me:pass@localhost/mydatabase'</A> )
</I>&gt;<i>     req.register_cleanup(close_db, req.db)
</I>&gt;<i>     delete_stuff(req)
</I>&gt;<i>     add_stuff(req)
</I>&gt;<i>     req.write('stuff done')
</I>&gt;<i>     return apache.OK
</I>&gt;<i>
</I>&gt;<i> def add_stuff(req):
</I>&gt;<i>     cur = req.db.cursor()
</I>&gt;<i>     cur.execute(&quot;insert into stuff (foo) values ('bar')&quot;)
</I>&gt;<i>     cur.close()
</I>&gt;<i>
</I>&gt;<i> def add_stuff(req):
</I>&gt;<i>     cur = req.db.cursor()
</I>&gt;<i>     cur.execute(&quot;DELETE from stuff where foo = 'baz'&quot;)
</I>&gt;<i>     cur.close()
</I>&gt;<i>
</I>&gt;<i> def close_db(db):
</I>&gt;<i>     db.close()
</I>&gt;<i>
</I>&gt;<i> Notice the use of register_cleanup() to register a function which  
</I>&gt;<i> will close the connection, rather than explicitly closing it. This  
</I>&gt;<i> ensures that your db connection will always be closed, even if an  
</I>&gt;<i> exception occurs somewhere in your code.
</I>&gt;<i>
</I>&gt;<i> Jim
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mod_python mailing list
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022084.html">[mod_python] Very odd behavior using mysqldb
</A></li>
	<LI>Next message: <A HREF="022090.html">[mod_python] Very odd behavior using mysqldb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22088">[ date ]</a>
              <a href="thread.html#22088">[ thread ]</a>
              <a href="subject.html#22088">[ subject ]</a>
              <a href="author.html#22088">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
