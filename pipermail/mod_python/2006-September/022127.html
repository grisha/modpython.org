<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Cookies &amp; mod_rewrite
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Cookies%20%26%20mod_rewrite&In-Reply-To=30213CE8581C6C418BD0941763A1E2D4353770%40lonms01001.fm.rbsgrp.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022108.html">
   <LINK REL="Next"  HREF="022111.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Cookies &amp; mod_rewrite</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Deron Meranda</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Cookies%20%26%20mod_rewrite&In-Reply-To=30213CE8581C6C418BD0941763A1E2D4353770%40lonms01001.fm.rbsgrp.net"
       TITLE="[mod_python] Cookies &amp; mod_rewrite">deron.meranda at gmail.com
       </A><BR>
    <I>Tue Sep 26 17:02:40 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022108.html">[mod_python] Cookies &amp; mod_rewrite
</A></li>
        <LI>Next message: <A HREF="022111.html">[mod_python] Integration of CGI with Mod Python
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22127">[ date ]</a>
              <a href="thread.html#22127">[ thread ]</a>
              <a href="subject.html#22127">[ subject ]</a>
              <a href="author.html#22127">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 9/20/06, CARTWRIGHT, Guy, GBM &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Guy.CARTWRIGHT at rbos.com</A>&gt; wrote:
&gt;<i> &gt;  From memory, you can set req.headers_in and it will go
</I>&gt;<i> &gt; through to backend via proxy. Give it a try anyway. Simply go:
</I>&gt;<i> &gt;    req.headers_in['X-MyHeader'] = 'test'
</I>&gt;<i> &gt; and see if it gets through.
</I>&gt;<i>
</I>&gt;<i> No luck with the above, or with:
</I>&gt;<i>     req.headers_out['X-MyHeader'] = 'test'
</I>
Hmm, setting req.headers_in should allow you to pass additional
headers onto the reverse proxied &quot;backend&quot; server.  It does need
to be in an early phase, such as fixups or access.  Remember that
you are modifying (or adding to) the client's headers on their
way into the request, hence the headers_in instead of headers_out.

Be aware that some special headers will be filtered out though by the
mod_proxy handler, such as proxy related or headers like Max-Forwards,
Via, X-Forwarded-*, or any hop-specific headers such as Connection or
Transfer-Encoding.  But all other non-special headers should be passed
through.  mod_proxy can be configured to do some URL munging though,
so check if you have any ProxyPassReverseCookie* directives.

I can definitely get synthetic cookies working with just plain mod_proxy
using the ProxyPass directive, such as:

&lt;Location /proxytest&gt;
    PythonAccessHandler myproxymod::revproxyhandler
    PythonDebug On
    ProxyPass <A HREF="http://my.backend.server/content">http://my.backend.server/content</A>
&lt;/Location&gt;

And my handler code is just:
  def revproxyhandler(req):
      req.headers_in['X-This-Is-A-Test'] = 'Hello'
      return apache.OK

You can of course use an Auth* handler, Fixup, etc. as long as it's
before the main request processing phase (and after mapping or
storage phases).

I can't seem to get mod_rewrite's [P] flag to work currently though.
But I'm sure I just don't understand mod_rewrite well enough.

Just curious--why you are using mod_rewrite in this case
since mod_proxy should be sufficient (you're not really using
any regex functionality).

&gt;<i> but the following does work and gets passed through to the back-end
</I>&gt;<i> server...
</I>&gt;<i>     req.err_headers_out['X-MyHeader'] = 'test'
</I>&gt;<i>     return apache.OK
</I>&gt;<i> Weird...
</I>
Can't explain that one either!

Also just a few notes on security.  I assume your backend server
is checking it's authentication by looking for this cookie.  And your
front-end proxy server is doing NTLM and synthetically creating
that cookie.

Realize that this cookie should be &quot;private&quot; between your webserver
and the backend server.  At a minimum you should make sure that
the browser can never send this cookie in a Cookie header.  So you
should probably always delete it from the req.headers_in.
-- 
Deron Meranda
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022108.html">[mod_python] Cookies &amp; mod_rewrite
</A></li>
	<LI>Next message: <A HREF="022111.html">[mod_python] Integration of CGI with Mod Python
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22127">[ date ]</a>
              <a href="thread.html#22127">[ thread ]</a>
              <a href="subject.html#22127">[ subject ]</a>
              <a href="author.html#22127">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
