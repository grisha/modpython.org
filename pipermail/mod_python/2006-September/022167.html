<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Raising Exceptions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Raising%20Exceptions&In-Reply-To=e37997d0609290309i295b8154j53229ac44e0fa501%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022159.html">
   <LINK REL="Next"  HREF="022169.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Raising Exceptions</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Raising%20Exceptions&In-Reply-To=e37997d0609290309i295b8154j53229ac44e0fa501%40mail.gmail.com"
       TITLE="[mod_python] Raising Exceptions">grahamd at dscpl.com.au
       </A><BR>
    <I>Sat Sep 30 03:13:38 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022159.html">[mod_python] Raising Exceptions
</A></li>
        <LI>Next message: <A HREF="022169.html">[mod_python] Raising Exceptions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22167">[ date ]</a>
              <a href="thread.html#22167">[ thread ]</a>
              <a href="subject.html#22167">[ subject ]</a>
              <a href="author.html#22167">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>What you have uncovered is a symptom of some of the problems that
exist in the module importer in mod_python. The main thing this example
touches on is that the module importer tries to support itself the  
loading
of Python packages. This causes various problems and for that reason,
mod_python will not do that in mod_python 3.3 and will always defer to
the standard Python importer for importing of packages.

The consequences of this change and other changes in mod_python 3.3
though are that the way you are trying to structure all of your code  
in the
document tree as one big package will not necessarily work by default in
mod_python 3.3. To get it to work you will need to override module  
search
paths with the PythonPath directive and will have to be very careful not
to mix Python packages and file based modules in the top directory where
your PythonHandler directive is used.

Finally, these changes in mod_python 3.3 will mean that there will be no
automatic module reloading on Python code structured as Python
packages. Thus, you will need to restart Apache every time you make a
change to your code due to the way you use packages. Automatic
module reloading still works with file based Python modules though,
but your code isn't configured that way.

Anyway, the key problem arises from the fact that you have put the
definition of the MyError exception class in test/__init__.py. This  
combines
with problems in the module importer whereby it performs redundant  
reloads
of __init__.py files within a package. Turns out that this is a  
particular
issue I haven't noted before and thus it isn't documented in the list of
importer problems described at:

   <A HREF="http://www.dscpl.com.au/wiki/ModPython/Articles/">http://www.dscpl.com.au/wiki/ModPython/Articles/</A> 
ModuleImportingIsBroken

That you are mixing import and apache.import_module() could still have
resulted in redundant reloads at other times though and thus similar
problems. See ISSUE 9 and 10 in that document.

Stepping through this, the first thing that happens when the request  
arrives
is that mod_python uses apache.import_module() to load your top level
handler module test.dispatcher and executes the handler in it.  
Because it
is part of a package, it first loads test/__init__.py and then the  
sub module
test/dispatcher.py to simulate true package loading. In test/ 
dispatcher.py it
uses import to get the class MyError. This comes from the test/ 
__init__.py
just loaded and already stored in sys.modules.

The next thing is that apache.import_module() is asked to import the
module test.handlers.testhandler. The apache.import_module() detects  
that
the module hasn't been loaded before and so needs to load it. The  
problem
is the importer doesn't check whether it has already loaded the  
__init__.py
files already for that directory or any parent directories of the  
package and
thus proceeds to load the test/__init__.py file (a second time) and  
then the
test/handlers/__init__.py file.

That test/__init__.py is loaded a second time is now the trigger for the
problem. This is because in reloading the file the definition of  
MyError is
replaced with a new instances loaded from the file. At this point,  
because
you imported MyError as:

   from test import MyError

the test/dispatcher.py file holds a reference to the version of  
MyError from
before the reload. Ie., not the same as that now in test/__init__.py.  
Now
when test.handlers.testhandler gets loaded, it will find the newer  
version
of MyError in test/__init__.py. When the testhandler handler raises  
MyError
it is using the new MyError whereas as the top level handler is  
expecting
to see the old MyError. Because they are different they will not  
match and
so it will get caught as an Exception instead.

How do you solve this with the current module importer? The quick answer
is to never put anything in the __init__.py files of packages being  
imported
using apache.import_module().

Graham

On 29/09/2006, at 8:09 PM, John Keyes wrote:

&gt;<i> Hi guys,
</I>&gt;<i>
</I>&gt;<i> I've included some test code (see below) for some weird
</I>&gt;<i> behaviour I've noticed.
</I>&gt;<i>
</I>&gt;<i> I have dispatcher.py set up as a handler which dynamically
</I>&gt;<i> imports another handler (testhandler.py) and then calls
</I>&gt;<i> it's handler function.
</I>&gt;<i>
</I>&gt;<i> The handler function in testhandler throws a user defined
</I>&gt;<i> exception (see __init__.py) which the dispatcher is
</I>&gt;<i> explicity set up to catch (see except MyError).
</I>&gt;<i>
</I>&gt;<i> If I import testhandler using apache.import_module I
</I>&gt;<i> get the following output:
</I>&gt;<i>
</I>&gt;<i>  test
</I>&gt;<i>  testhandler - b4 raise
</I>&gt;<i>  exception - MyError - jk
</I>&gt;<i>
</I>&gt;<i> Yet if I use __import__ and getattr I get the following
</I>&gt;<i> output:
</I>&gt;<i>
</I>&gt;<i>  test
</I>&gt;<i>  testhandler - b4 raise
</I>&gt;<i>  myerror
</I>&gt;<i>
</I>&gt;<i> As you can see using import_module the incorrect except
</I>&gt;<i> block is executed, but the class name of the exception
</I>&gt;<i> is correct.
</I>&gt;<i>
</I>&gt;<i> Can anyone explain to me why this is the case?
</I>&gt;<i>
</I>&gt;<i> I've the code included inline but if you want to run the
</I>&gt;<i> code I've attached a zip file as well.
</I>&gt;<i>
</I>&gt;<i> Apache     - 2.0.58
</I>&gt;<i> mod_python - 3.2.8
</I>&gt;<i> Python     - 2.4.3
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> -John K
</I>&gt;<i>
</I>&gt;<i> == test.__init__.py ==
</I>&gt;<i> class MyError(Exception):
</I>&gt;<i>    def __init__(self, msg):
</I>&gt;<i>        self.msg = msg
</I>&gt;<i>
</I>&gt;<i>    def __str__(self):
</I>&gt;<i>        return self.msg
</I>&gt;<i>
</I>&gt;<i> == test.dispatcher.py ==
</I>&gt;<i> from mod_python import apache
</I>&gt;<i>
</I>&gt;<i> from test import MyError
</I>&gt;<i>
</I>&gt;<i> def handler(req):
</I>&gt;<i>    req.write(&quot;\ntest&quot;)
</I>&gt;<i>
</I>&gt;<i>    try:
</I>&gt;<i>        #test_handler = apache.import_module 
</I>&gt;<i> ('test.handlers.testhandler')
</I>&gt;<i>        test_handler = my_import('test.handlers.testhandler')
</I>&gt;<i>        val = test_handler.handler(req)
</I>&gt;<i>    except MyError, me:
</I>&gt;<i>        req.write(&quot;\nmyerror&quot;)
</I>&gt;<i>    except Exception, e:
</I>&gt;<i>        req.write(&quot;\nexception - %s - %s&quot; % (e.__class__.__name__, e))
</I>&gt;<i>
</I>&gt;<i>    return apache.OK
</I>&gt;<i>
</I>&gt;<i> def my_import(name):
</I>&gt;<i>    mod = __import__(name)
</I>&gt;<i>    components = name.split('.')
</I>&gt;<i>    for comp in components[1:]:
</I>&gt;<i>        mod = getattr(mod, comp)
</I>&gt;<i>    return mod
</I>&gt;<i>
</I>&gt;<i> == test.handlers.testhandler.py ==
</I>&gt;<i> from mod_python import apache
</I>&gt;<i>
</I>&gt;<i> from test import MyError
</I>&gt;<i>
</I>&gt;<i> def handler(req):
</I>&gt;<i>    req.write(&quot;\ntesthandler - b4 raise&quot;)
</I>&gt;<i>
</I>&gt;<i>    raise MyError('jk')
</I>&gt;<i>
</I>&gt;<i>    req.write(&quot;\ntesthandler - af raise&quot;)
</I>&gt;<i>    return apache.OK
</I>&gt;<i> &lt;import_test.zip&gt;
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mod_python mailing list
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022159.html">[mod_python] Raising Exceptions
</A></li>
	<LI>Next message: <A HREF="022169.html">[mod_python] Raising Exceptions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22167">[ date ]</a>
              <a href="thread.html#22167">[ thread ]</a>
              <a href="subject.html#22167">[ subject ]</a>
              <a href="author.html#22167">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
