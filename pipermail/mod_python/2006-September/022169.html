<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Raising Exceptions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Raising%20Exceptions&In-Reply-To=2F2E0E3D-D8A5-495A-A8F8-FE4744BF9546%40dscpl.com.au">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022167.html">
   <LINK REL="Next"  HREF="022160.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Raising Exceptions</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>John Keyes</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Raising%20Exceptions&In-Reply-To=2F2E0E3D-D8A5-495A-A8F8-FE4744BF9546%40dscpl.com.au"
       TITLE="[mod_python] Raising Exceptions">john.keyes at secantus.com
       </A><BR>
    <I>Sat Sep 30 18:27:58 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022167.html">[mod_python] Raising Exceptions
</A></li>
        <LI>Next message: <A HREF="022160.html">[mod_python] NAV mod_python.publisher errors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22169">[ date ]</a>
              <a href="thread.html#22169">[ thread ]</a>
              <a href="subject.html#22169">[ subject ]</a>
              <a href="author.html#22169">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jeez Graham that's a hefty response!

I moved the exceptions to a separate module and everything
works.

I'll have to re-read the entire response again to make sure
I understand what's going on here.

Thanks for your help,
-John K

On 9/30/06, Graham Dumpleton &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">grahamd at dscpl.com.au</A>&gt; wrote:
&gt;<i> What you have uncovered is a symptom of some of the problems that
</I>&gt;<i> exist in the module importer in mod_python. The main thing this example
</I>&gt;<i> touches on is that the module importer tries to support itself the
</I>&gt;<i> loading
</I>&gt;<i> of Python packages. This causes various problems and for that reason,
</I>&gt;<i> mod_python will not do that in mod_python 3.3 and will always defer to
</I>&gt;<i> the standard Python importer for importing of packages.
</I>&gt;<i>
</I>&gt;<i> The consequences of this change and other changes in mod_python 3.3
</I>&gt;<i> though are that the way you are trying to structure all of your code
</I>&gt;<i> in the
</I>&gt;<i> document tree as one big package will not necessarily work by default in
</I>&gt;<i> mod_python 3.3. To get it to work you will need to override module
</I>&gt;<i> search
</I>&gt;<i> paths with the PythonPath directive and will have to be very careful not
</I>&gt;<i> to mix Python packages and file based modules in the top directory where
</I>&gt;<i> your PythonHandler directive is used.
</I>&gt;<i>
</I>&gt;<i> Finally, these changes in mod_python 3.3 will mean that there will be no
</I>&gt;<i> automatic module reloading on Python code structured as Python
</I>&gt;<i> packages. Thus, you will need to restart Apache every time you make a
</I>&gt;<i> change to your code due to the way you use packages. Automatic
</I>&gt;<i> module reloading still works with file based Python modules though,
</I>&gt;<i> but your code isn't configured that way.
</I>&gt;<i>
</I>&gt;<i> Anyway, the key problem arises from the fact that you have put the
</I>&gt;<i> definition of the MyError exception class in test/__init__.py. This
</I>&gt;<i> combines
</I>&gt;<i> with problems in the module importer whereby it performs redundant
</I>&gt;<i> reloads
</I>&gt;<i> of __init__.py files within a package. Turns out that this is a
</I>&gt;<i> particular
</I>&gt;<i> issue I haven't noted before and thus it isn't documented in the list of
</I>&gt;<i> importer problems described at:
</I>&gt;<i>
</I>&gt;<i>    <A HREF="http://www.dscpl.com.au/wiki/ModPython/Articles/">http://www.dscpl.com.au/wiki/ModPython/Articles/</A>
</I>&gt;<i> ModuleImportingIsBroken
</I>&gt;<i>
</I>&gt;<i> That you are mixing import and apache.import_module() could still have
</I>&gt;<i> resulted in redundant reloads at other times though and thus similar
</I>&gt;<i> problems. See ISSUE 9 and 10 in that document.
</I>&gt;<i>
</I>&gt;<i> Stepping through this, the first thing that happens when the request
</I>&gt;<i> arrives
</I>&gt;<i> is that mod_python uses apache.import_module() to load your top level
</I>&gt;<i> handler module test.dispatcher and executes the handler in it.
</I>&gt;<i> Because it
</I>&gt;<i> is part of a package, it first loads test/__init__.py and then the
</I>&gt;<i> sub module
</I>&gt;<i> test/dispatcher.py to simulate true package loading. In test/
</I>&gt;<i> dispatcher.py it
</I>&gt;<i> uses import to get the class MyError. This comes from the test/
</I>&gt;<i> __init__.py
</I>&gt;<i> just loaded and already stored in sys.modules.
</I>&gt;<i>
</I>&gt;<i> The next thing is that apache.import_module() is asked to import the
</I>&gt;<i> module test.handlers.testhandler. The apache.import_module() detects
</I>&gt;<i> that
</I>&gt;<i> the module hasn't been loaded before and so needs to load it. The
</I>&gt;<i> problem
</I>&gt;<i> is the importer doesn't check whether it has already loaded the
</I>&gt;<i> __init__.py
</I>&gt;<i> files already for that directory or any parent directories of the
</I>&gt;<i> package and
</I>&gt;<i> thus proceeds to load the test/__init__.py file (a second time) and
</I>&gt;<i> then the
</I>&gt;<i> test/handlers/__init__.py file.
</I>&gt;<i>
</I>&gt;<i> That test/__init__.py is loaded a second time is now the trigger for the
</I>&gt;<i> problem. This is because in reloading the file the definition of
</I>&gt;<i> MyError is
</I>&gt;<i> replaced with a new instances loaded from the file. At this point,
</I>&gt;<i> because
</I>&gt;<i> you imported MyError as:
</I>&gt;<i>
</I>&gt;<i>    from test import MyError
</I>&gt;<i>
</I>&gt;<i> the test/dispatcher.py file holds a reference to the version of
</I>&gt;<i> MyError from
</I>&gt;<i> before the reload. Ie., not the same as that now in test/__init__.py.
</I>&gt;<i> Now
</I>&gt;<i> when test.handlers.testhandler gets loaded, it will find the newer
</I>&gt;<i> version
</I>&gt;<i> of MyError in test/__init__.py. When the testhandler handler raises
</I>&gt;<i> MyError
</I>&gt;<i> it is using the new MyError whereas as the top level handler is
</I>&gt;<i> expecting
</I>&gt;<i> to see the old MyError. Because they are different they will not
</I>&gt;<i> match and
</I>&gt;<i> so it will get caught as an Exception instead.
</I>&gt;<i>
</I>&gt;<i> How do you solve this with the current module importer? The quick answer
</I>&gt;<i> is to never put anything in the __init__.py files of packages being
</I>&gt;<i> imported
</I>&gt;<i> using apache.import_module().
</I>&gt;<i>
</I>&gt;<i> Graham
</I>&gt;<i>
</I>&gt;<i> On 29/09/2006, at 8:09 PM, John Keyes wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; Hi guys,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I've included some test code (see below) for some weird
</I>&gt;<i> &gt; behaviour I've noticed.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have dispatcher.py set up as a handler which dynamically
</I>&gt;<i> &gt; imports another handler (testhandler.py) and then calls
</I>&gt;<i> &gt; it's handler function.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The handler function in testhandler throws a user defined
</I>&gt;<i> &gt; exception (see __init__.py) which the dispatcher is
</I>&gt;<i> &gt; explicity set up to catch (see except MyError).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If I import testhandler using apache.import_module I
</I>&gt;<i> &gt; get the following output:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  test
</I>&gt;<i> &gt;  testhandler - b4 raise
</I>&gt;<i> &gt;  exception - MyError - jk
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yet if I use __import__ and getattr I get the following
</I>&gt;<i> &gt; output:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  test
</I>&gt;<i> &gt;  testhandler - b4 raise
</I>&gt;<i> &gt;  myerror
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As you can see using import_module the incorrect except
</I>&gt;<i> &gt; block is executed, but the class name of the exception
</I>&gt;<i> &gt; is correct.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Can anyone explain to me why this is the case?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I've the code included inline but if you want to run the
</I>&gt;<i> &gt; code I've attached a zip file as well.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Apache     - 2.0.58
</I>&gt;<i> &gt; mod_python - 3.2.8
</I>&gt;<i> &gt; Python     - 2.4.3
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Cheers,
</I>&gt;<i> &gt; -John K
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; == test.__init__.py ==
</I>&gt;<i> &gt; class MyError(Exception):
</I>&gt;<i> &gt;    def __init__(self, msg):
</I>&gt;<i> &gt;        self.msg = msg
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def __str__(self):
</I>&gt;<i> &gt;        return self.msg
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; == test.dispatcher.py ==
</I>&gt;<i> &gt; from mod_python import apache
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; from test import MyError
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; def handler(req):
</I>&gt;<i> &gt;    req.write(&quot;\ntest&quot;)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    try:
</I>&gt;<i> &gt;        #test_handler = apache.import_module
</I>&gt;<i> &gt; ('test.handlers.testhandler')
</I>&gt;<i> &gt;        test_handler = my_import('test.handlers.testhandler')
</I>&gt;<i> &gt;        val = test_handler.handler(req)
</I>&gt;<i> &gt;    except MyError, me:
</I>&gt;<i> &gt;        req.write(&quot;\nmyerror&quot;)
</I>&gt;<i> &gt;    except Exception, e:
</I>&gt;<i> &gt;        req.write(&quot;\nexception - %s - %s&quot; % (e.__class__.__name__, e))
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    return apache.OK
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; def my_import(name):
</I>&gt;<i> &gt;    mod = __import__(name)
</I>&gt;<i> &gt;    components = name.split('.')
</I>&gt;<i> &gt;    for comp in components[1:]:
</I>&gt;<i> &gt;        mod = getattr(mod, comp)
</I>&gt;<i> &gt;    return mod
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; == test.handlers.testhandler.py ==
</I>&gt;<i> &gt; from mod_python import apache
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; from test import MyError
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; def handler(req):
</I>&gt;<i> &gt;    req.write(&quot;\ntesthandler - b4 raise&quot;)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    raise MyError('jk')
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    req.write(&quot;\ntesthandler - af raise&quot;)
</I>&gt;<i> &gt;    return apache.OK
</I>&gt;<i> &gt; &lt;import_test.zip&gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mod_python mailing list
</I>&gt;<i> &gt; <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;<i> &gt; <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>&gt;<i>
</I></PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022167.html">[mod_python] Raising Exceptions
</A></li>
	<LI>Next message: <A HREF="022160.html">[mod_python] NAV mod_python.publisher errors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22169">[ date ]</a>
              <a href="thread.html#22169">[ thread ]</a>
              <a href="subject.html#22169">[ subject ]</a>
              <a href="author.html#22169">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
