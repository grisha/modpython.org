<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Very odd behavior using mysqldb
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Very%20odd%20behavior%20using%20mysqldb&In-Reply-To=46D678A0-D225-4869-8CA2-ED7A8860744D%40dscpl.com.au">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022088.html">
   <LINK REL="Next"  HREF="022086.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Very odd behavior using mysqldb</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Eric Brunson</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Very%20odd%20behavior%20using%20mysqldb&In-Reply-To=46D678A0-D225-4869-8CA2-ED7A8860744D%40dscpl.com.au"
       TITLE="[mod_python] Very odd behavior using mysqldb">brunson at brunson.com
       </A><BR>
    <I>Sun Sep 17 14:02:20 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022088.html">[mod_python] Very odd behavior using mysqldb
</A></li>
        <LI>Next message: <A HREF="022086.html">[mod_python] Very odd behavior using mysqldb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22090">[ date ]</a>
              <a href="thread.html#22090">[ thread ]</a>
              <a href="subject.html#22090">[ subject ]</a>
              <a href="author.html#22090">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Jim and Graham,

Thanks for the replies, it's good to have my suspicions confirmed and 
better explained.  Jim, thanks especially for the tip on adding the 
database connection as an attribute of the req.  The main think I didn't 
like about instantiating the connection in the handler was having to 
pass yet another argument to my function calls.  This will clean up my 
code quite a bit.

Thanks again,
e.

Graham Dumpleton wrote:
&gt;<i> In addition to what Jim has says, having the database connection created
</I>&gt;<i> at global module scope of a handler code file isn't necessarily a good 
</I>&gt;<i> idea.
</I>&gt;<i> The problem here is if automatic module reloading is on and you make 
</I>&gt;<i> changes
</I>&gt;<i> to your handler file over time. What will happen is that when the 
</I>&gt;<i> handler code
</I>&gt;<i> file is reloaded, your existing database connection objects will be 
</I>&gt;<i> discarded
</I>&gt;<i> and reinitialised. If normal object cleanup doesn't result in the 
</I>&gt;<i> database
</I>&gt;<i> handles being cleaned up properly, you can get a leak in database 
</I>&gt;<i> resource
</I>&gt;<i> handles and eventually you will run out of connections to the database.
</I>&gt;<i>
</I>&gt;<i> For details on issues like this and others which will affect you with 
</I>&gt;<i> the version
</I>&gt;<i> of mod_python you are running, check out:
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;<i> <A HREF="http://www.dscpl.com.au/wiki/ModPython/Articles/TheProcessInterpreterModel">http://www.dscpl.com.au/wiki/ModPython/Articles/TheProcessInterpreterModel</A> 
</I>&gt;<i>
</I>&gt;<i>   <A HREF="http://www.dscpl.com.au/wiki/ModPython/Articles/ModuleImportingIsBroken">http://www.dscpl.com.au/wiki/ModPython/Articles/ModuleImportingIsBroken</A>
</I>&gt;<i>
</I>&gt;<i> Graham
</I>&gt;<i>
</I>&gt;<i> On 17/09/2006, at 3:44 AM, Jim Gallacher wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Eric Brunson wrote:
</I>&gt;&gt;&gt;<i> I've been working on a project using mod_python to access a mysql 
</I>&gt;&gt;&gt;<i> database using the MySQLdb API.  I know mod_python is still 
</I>&gt;&gt;&gt;<i> considered beta under Apache 2, so I thought I'd bring an issue to 
</I>&gt;&gt;&gt;<i> the attention of the list.
</I>&gt;&gt;&gt;<i> I was seeing some very bizarre results when generating dynamic 
</I>&gt;&gt;&gt;<i> content from the database, which I first attributed to PSP caching, 
</I>&gt;&gt;&gt;<i> but then investigated further when I switched to using the publisher 
</I>&gt;&gt;&gt;<i> handler.  It may be the way I've set up my modules and database 
</I>&gt;&gt;&gt;<i> connections, but I haven't convinced myself that I really understand 
</I>&gt;&gt;&gt;<i> the problem and until I do, I'm not going to be happy about it.  I 
</I>&gt;&gt;&gt;<i> have found a workaround that I can live with, but I don't really 
</I>&gt;&gt;&gt;<i> like it that much because it requires constantly connecting to and 
</I>&gt;&gt;&gt;<i> disconnection from the database.
</I>&gt;&gt;&gt;<i> The problem was simply getting old, wrong results interleaved with 
</I>&gt;&gt;&gt;<i> new, correct results after updating the database.  Simply put, I'm 
</I>&gt;&gt;&gt;<i> displaying data from a table.  My index.py imports a module for 
</I>&gt;&gt;&gt;<i> generating HTML which, in turn, includes a module for doing database 
</I>&gt;&gt;&gt;<i> access.  The odd thing about how I set up the database access, and I 
</I>&gt;&gt;&gt;<i> think it's pertinent to the problem, was that I automatically 
</I>&gt;&gt;&gt;<i> connect to the database when I import the database module.  Like this:
</I>&gt;&gt;&gt;<i> ----- database.py -----
</I>&gt;&gt;&gt;<i> import MySQLdb
</I>&gt;&gt;&gt;<i> from mod_python import apache
</I>&gt;&gt;&gt;<i> def Connect():
</I>&gt;&gt;&gt;<i>    return MySQLdb.connect( '<A HREF="mysql://me:pass@localhost/mydatabase'">mysql://me:pass@localhost/mydatabase'</A> )
</I>&gt;&gt;&gt;<i> dbc = Connect()
</I>&gt;&gt;&gt;<i> def someExampleAccessFunction():
</I>&gt;&gt;&gt;<i>    global dbc
</I>&gt;&gt;&gt;<i>    curs = dbc.cursor()
</I>&gt;&gt;&gt;<i>    curs.execute( &quot;select count(0) from sometable&quot; )
</I>&gt;&gt;&gt;<i>    result = curs.fetchall()[0][0]
</I>&gt;&gt;&gt;<i>    curs.close()
</I>&gt;&gt;&gt;<i>    apache.log_error( &quot;result was %s&quot; % result )
</I>&gt;&gt;&gt;<i>    return result
</I>&gt;&gt;&gt;<i> ----- end database.py -----
</I>&gt;&gt;&gt;<i> Let's disregard whether that's good programming practice or not, the 
</I>&gt;&gt;&gt;<i> fact is, I could query that value several times by doing a page 
</I>&gt;&gt;&gt;<i> reload, then delete a record from the database and commit the 
</I>&gt;&gt;&gt;<i> change, then subsequent page loads would interleave old results with 
</I>&gt;&gt;&gt;<i> new results, seemingly cyclically.
</I>&gt;&gt;&gt;<i> The key to my confusion is that the error logs for apache would show 
</I>&gt;&gt;&gt;<i> a message for every page reload, and the result from the query would 
</I>&gt;&gt;&gt;<i> agree with whatever data was displayed on the page, correct or 
</I>&gt;&gt;&gt;<i> incorrect.  Meanwhile a direct query to the database from the 
</I>&gt;&gt;&gt;<i> command line would always return the correct result from the database.
</I>&gt;&gt;&gt;<i> My best guess so far is that multiple threads in apache get multiple 
</I>&gt;&gt;&gt;<i> copies of mod_python, each with it's own copy of the imported 
</I>&gt;&gt;&gt;<i> database module in memory and each module maintaining a different 
</I>&gt;&gt;&gt;<i> database connection that is somehow caching results.  I've never 
</I>&gt;&gt;&gt;<i> seen this behavior in any application until I tried this under 
</I>&gt;&gt;&gt;<i> mod_python.  I was able to force the correct results to always be 
</I>&gt;&gt;&gt;<i> returned by getting rid of the module variable, dbc, and moving the 
</I>&gt;&gt;&gt;<i> mysqldb.connect() call to inside each function call, opening the 
</I>&gt;&gt;&gt;<i> database connection, executing my sql, then closing the database 
</I>&gt;&gt;&gt;<i> connection.  This is less than optimal, since I may make several 
</I>&gt;&gt;&gt;<i> database queries during each page load, so later today I'll try 
</I>&gt;&gt;&gt;<i> making the database connection in the index.py, then passing the 
</I>&gt;&gt;&gt;<i> connection handle to each of the calls that need it.  Also a little 
</I>&gt;&gt;&gt;<i> less than optimal, but tolerable.
</I>&gt;&gt;&gt;<i> Does anyone have any insight into this behavior?  It's more of an 
</I>&gt;&gt;&gt;<i> academic question at this point, but I wonder if it may lead to an 
</I>&gt;&gt;&gt;<i> improvement if we were able to identify the problem and implement a 
</I>&gt;&gt;&gt;<i> transparent fix.  Also, feel free to let me know if I'm completely 
</I>&gt;&gt;&gt;<i> offbase with my theory of what's going on under the hood.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Your assessment with respect to having multiple copies of mod_python, 
</I>&gt;&gt;<i> each with its own copy of the imported modules and data is correct. 
</I>&gt;&gt;<i> It is not a bug but rather the way apache works. Depending on which 
</I>&gt;&gt;<i> apache-mpm you are using (either prefork or worker on Fedora) and 
</I>&gt;&gt;<i> your configuration, you may have anywhere from a few, to dozens of 
</I>&gt;&gt;<i> independent child processes. Indeed if you are using the prefork mpm 
</I>&gt;&gt;<i> on a heavily loaded server you could have hundreds of processes. In 
</I>&gt;&gt;<i> such cases using a persistent db connection will likely cause 
</I>&gt;&gt;<i> problems with exhausting the number of available mysql connections. 
</I>&gt;&gt;<i> Persistent connections in such a scenario are discouraged in general 
</I>&gt;&gt;<i> - not just in mod_python.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As to your particular problem, I wonder if you are using 
</I>&gt;&gt;<i> transactions, but are not committing immediately after an update? The 
</I>&gt;&gt;<i> process which apache chooses to to handle a request is random. Say 
</I>&gt;&gt;<i> for example you update in process A without a commit. The next 
</I>&gt;&gt;<i> request may be handled by  another process, which will see the old 
</I>&gt;&gt;<i> data. A subsequent request may then come in but be handled by process 
</I>&gt;&gt;<i> A again, which will see the new data since it is using the same 
</I>&gt;&gt;<i> connection as that used for the update. Thus you will get the 
</I>&gt;&gt;<i> interleaving effect.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is not unique to db connections. Don't be fooled into thinking 
</I>&gt;&gt;<i> that module-level attributes are global across your application as 
</I>&gt;&gt;<i> they are not. In anything other than winnt-mpm (which is a single, 
</I>&gt;&gt;<i> threaded process), you will have multiple, independent copies of that 
</I>&gt;&gt;<i> variable.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Opening and closing your db connection for each request is the usual 
</I>&gt;&gt;<i> solution, as you've discovered. It is possible to do connection 
</I>&gt;&gt;<i> pooling, but you need to be a little smarter about it ensure you 
</I>&gt;&gt;<i> don't run into problems or exhaust the number of mysql connections 
</I>&gt;&gt;<i> configured. Don't forget that leaving open a connection consumes 
</I>&gt;&gt;<i> memory resources as well.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is not to say that you need to open and close the connection 
</I>&gt;&gt;<i> each time you want to access the database within a request. The usual 
</I>&gt;&gt;<i> method is to stuff your db connection into the request object itself. 
</I>&gt;&gt;<i> For example:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> def handler(req):
</I>&gt;&gt;<i>     req.db = MySQLdb.connect( '<A HREF="mysql://me:pass@localhost/mydatabase'">mysql://me:pass@localhost/mydatabase'</A> )
</I>&gt;&gt;<i>     req.register_cleanup(close_db, req.db)
</I>&gt;&gt;<i>     delete_stuff(req)
</I>&gt;&gt;<i>     add_stuff(req)
</I>&gt;&gt;<i>     req.write('stuff done')
</I>&gt;&gt;<i>     return apache.OK
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> def add_stuff(req):
</I>&gt;&gt;<i>     cur = req.db.cursor()
</I>&gt;&gt;<i>     cur.execute(&quot;insert into stuff (foo) values ('bar')&quot;)
</I>&gt;&gt;<i>     cur.close()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> def add_stuff(req):
</I>&gt;&gt;<i>     cur = req.db.cursor()
</I>&gt;&gt;<i>     cur.execute(&quot;DELETE from stuff where foo = 'baz'&quot;)
</I>&gt;&gt;<i>     cur.close()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> def close_db(db):
</I>&gt;&gt;<i>     db.close()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Notice the use of register_cleanup() to register a function which 
</I>&gt;&gt;<i> will close the connection, rather than explicitly closing it. This 
</I>&gt;&gt;<i> ensures that your db connection will always be closed, even if an 
</I>&gt;&gt;<i> exception occurs somewhere in your code.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Jim
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mod_python mailing list
</I>&gt;&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022088.html">[mod_python] Very odd behavior using mysqldb
</A></li>
	<LI>Next message: <A HREF="022086.html">[mod_python] Very odd behavior using mysqldb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22090">[ date ]</a>
              <a href="thread.html#22090">[ thread ]</a>
              <a href="subject.html#22090">[ subject ]</a>
              <a href="author.html#22090">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
