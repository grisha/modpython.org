<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] IPC, db conn sharing, and other fine things
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20IPC%2C%20db%20conn%20sharing%2C%20and%20other%20fine%20things&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014087.html">
   <LINK REL="Next"  HREF="014090.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] IPC, db conn sharing, and other fine things</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Mike Looijmans</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20IPC%2C%20db%20conn%20sharing%2C%20and%20other%20fine%20things&In-Reply-To="
       TITLE="[mod_python] IPC, db conn sharing, and other fine things">mike.looijmans at asml.com
       </A><BR>
    <I>Thu Aug 28 08:29:58 EST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="014087.html">[mod_python] Mod python sys.stdin 
</A></li>
        <LI>Next message: <A HREF="014090.html">[mod_python] IPC, db conn sharing, and other fine things
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14089">[ date ]</a>
              <a href="thread.html#14089">[ thread ]</a>
              <a href="subject.html#14089">[ subject ]</a>
              <a href="author.html#14089">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>As far as the global dictionaries suggestion, that will work within any
</I>&gt;<i>individual process, but each process will have to maintain their own
</I>&gt;<i>disparate cache and registry. I'd thought about it, and I'll probably
</I>&gt;<i>give it a shot just to see what the performance hit would be in running
</I>&gt;<i>them in each process.
</I>

One simple way to solve this is to force Apache into threading. I'm using
the MPM worker here (Solaris), so that over 20 connections share the same
process (but different threads). This works well for publisher and common
handlers, but this will NOT work for the cgihandler (which only allows one
active thread). A big advantage of the (worker) threading mpm is that you
only need one Python interpreter 'in the air', saving a few megabytes for
each child.

Simple multi-read-single-write strategy:

cachelock = threading.Lock()
#...

try:
    result = cache[key]
except KeyError:
    cachelock.aquire()
    try:
        # Read again, since some other thread may have done
        # the same now
        try:
            result = cache[key]
        except KeyError:
            result = someFetchingFunction(key)
            cache[key] = result
    finally:
        cachelock.release()
return result

With multiple processes, each process will gather the neccesary cache data
as it goes, so initially the system will be a bit slower but ramps up rather
quick as more data is cached. However, this does eat quite some memory, all
cache data is duplicated for each process.

&gt;<i>For right now I've hacked together a flat file-based caching/registry
</I>&gt;<i>system using libxml2 and fcntl locking. It's performance will work,
</I>&gt;<i>though I really miss the speed of an all-in-memory caching/registry
</I>&gt;<i>system. *sigh* You make do with what you can.
</I>
I think there are some Python shared memory (across processes) libraries,
they might be worth looking into. You could also write some caching code
based on shared memory in C and package it into a .so library and load it
into Python.

The filesystem is not so bad, most of it is cached in memory anyway. Some
OSses support in-memory files, that might be a nice one too.

Mike.



-- 
The information contained in this communication and any attachments is confidential and may be privileged, and is for the sole use of the intended recipient(s). Any unauthorized review, use, disclosure or distribution is prohibited. If you are not the intended recipient, please notify the sender immediately by replying to this message and destroy all copies of this message and any attachments. ASML is neither liable for the proper and complete transmission of the information contained in this communication, nor for any delay in its receipt.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014087.html">[mod_python] Mod python sys.stdin 
</A></li>
	<LI>Next message: <A HREF="014090.html">[mod_python] IPC, db conn sharing, and other fine things
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14089">[ date ]</a>
              <a href="thread.html#14089">[ thread ]</a>
              <a href="subject.html#14089">[ subject ]</a>
              <a href="author.html#14089">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
