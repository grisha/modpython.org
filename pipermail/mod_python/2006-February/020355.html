<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Re: Chunked encoding
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Re%3A%20Chunked%20encoding&In-Reply-To=4817b6fc0602182336y6603ae03k87f3312135230eb7%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020354.html">
   <LINK REL="Next"  HREF="020356.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Re: Chunked encoding</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Re%3A%20Chunked%20encoding&In-Reply-To=4817b6fc0602182336y6603ae03k87f3312135230eb7%40mail.gmail.com"
       TITLE="[mod_python] Re: Chunked encoding">grahamd at dscpl.com.au
       </A><BR>
    <I>Sun Feb 19 03:41:56 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020354.html">[mod_python] Re: Chunked encoding
</A></li>
        <LI>Next message: <A HREF="020356.html">[mod_python] Re: Chunked encoding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20355">[ date ]</a>
              <a href="thread.html#20355">[ thread ]</a>
              <a href="subject.html#20355">[ subject ]</a>
              <a href="author.html#20355">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On 19/02/2006, at 6:36 PM, Dan Eloff wrote:

&gt;<i> Well mostly it's just my C++ days coming back to haunt me, can't  
</I>&gt;<i> stand the thought of buffering large amounts of data for no reason  
</I>&gt;<i> at all. But it's just a minor concern, and for now performance is a  
</I>&gt;<i> non-issue, I'll cross that bridge when I get there. I was just  
</I>&gt;<i> wondering if there was a easy way to write data from my string to  
</I>&gt;<i> the browser, but that may not even be possible for all I know.
</I>
Well, req.write() is the right thing to use, but there are all sorts of
buffering and potential filtering going on. It doesn't necessarily get
written direct to the socket.

If you want some scary reading on what Apache calls the bucket
brigade and filtering in general, have a look at:

   <A HREF="http://www.projectcomputing.com/resources/apacheFilterFAQ/">http://www.projectcomputing.com/resources/apacheFilterFAQ/</A>

Graham

&gt;<i> Thanks Graham.
</I>&gt;<i> -Dan
</I>&gt;<i>
</I>&gt;<i> On 2/18/06, Graham Dumpleton &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">grahamd at dscpl.com.au</A>&gt; wrote:
</I>&gt;<i> On 19/02/2006, at 9:14 AM, Dan Eloff wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; I'm curious about this &quot;chunked encoding&quot; what does that mean? I
</I>&gt;<i> &gt; output all my pages in my handler as a single string, so I have a
</I>&gt;<i> &gt; sort of interest in understanding what the write method does. If
</I>&gt;<i> &gt; I'm to take a wild guess at how the below works, you set the
</I>&gt;<i> &gt; content length so that mod_python realizes when it recieves your
</I>&gt;<i> &gt; data string that no more is coming and it doesn't need to copy the
</I>&gt;<i> &gt; string into a buffer, it can just keep a reference to it? And
</I>&gt;<i> &gt; somehow the act of buffering the data as opposed to writing it
</I>&gt;<i> &gt; immediately causes mod_python not to emply this &quot;chunked encoding&quot;?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; It'd be great if someone explained this to me :)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Thanks,
</I>&gt;<i> &gt; -Dan
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On 2/15/06, Lars Eriksen &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">downgrade at gmx.org</A> &gt; wrote:Yes, there
</I>&gt;<i> &gt; is :-) RTFM, I guess ...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; from mod_python.util import *
</I>&gt;<i> &gt; from mod_python import apache
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; def handle(req):
</I>&gt;<i> &gt;     data = 'No chunking involved.' * 1024
</I>&gt;<i> &gt;     req.set_content_length (len(data))
</I>&gt;<i> &gt;     req.write(data, 0)
</I>&gt;<i> &gt;     req.flush()
</I>&gt;<i> &gt;     return apache.OK
</I>&gt;<i>
</I>&gt;<i> As far as I can tell, there is no difference between that and:
</I>&gt;<i>
</I>&gt;<i> def handler(req):
</I>&gt;<i>      data = 'No chunking involved.' * 1024
</I>&gt;<i>      req.set_content_length(len(data))
</I>&gt;<i>      req.write(data)
</I>&gt;<i>      return apache.OK
</I>&gt;<i>
</I>&gt;<i> When no second argument is supplied to req.write(), it automatically
</I>&gt;<i> flushes.
</I>&gt;<i>
</I>&gt;<i> In this particular case, since there is only one call to req.write(),
</I>&gt;<i> it is also
</I>&gt;<i> probably equivalent to:
</I>&gt;<i>
</I>&gt;<i> def handler(req):
</I>&gt;<i>      data = 'No chunking involved.' * 1024
</I>&gt;<i>      req.set_content_length(len(data))
</I>&gt;<i>      req.write(data,0)
</I>&gt;<i>      return apache.OK
</I>&gt;<i>
</I>&gt;<i> That is, returning apache.OK is going to have the same effect of
</I>&gt;<i> flushing the
</I>&gt;<i> buffered data if there is any.
</I>&gt;<i>
</I>&gt;<i> FWIW, chunked encoding is only of relevance to HTTP/1.1 clients. You
</I>&gt;<i> as the
</I>&gt;<i> provider of the handler does not really have to care about it as
</I>&gt;<i> Apache will
</I>&gt;<i> worry about it and use it if the client is capable of handling HTTP/
</I>&gt;<i> 1.1. That is,
</I>&gt;<i> mod_python doesn't do anything about chunked encoding either.
</I>&gt;<i>
</I>&gt;<i> As to the connection between req.set_content_length () and how much  
</I>&gt;<i> data
</I>&gt;<i> you write, there isn't really any. Calling req.set_content_length()
</I>&gt;<i> only has the
</I>&gt;<i> effect of setting the &quot;Content-Length&quot; response header. You could set
</I>&gt;<i> the
</I>&gt;<i> content length to a small value and write more data that you say
</I>&gt;<i> there will be
</I>&gt;<i> and mod_python/Apache will quite happily let you do it. A remote
</I>&gt;<i> client on
</I>&gt;<i> the other handle may well probably discard any extra content if it
</I>&gt;<i> honours the
</I>&gt;<i> content length header.
</I>&gt;<i>
</I>&gt;<i> For most people, how many times you call req.write() and whether  
</I>&gt;<i> you use
</I>&gt;<i> buffering isn't going to matter one bit. Some may want to minimise
</I>&gt;<i> the number
</I>&gt;<i> of calls to req.write() or use buffering for perceived performance
</I>&gt;<i> reasons (right
</I>&gt;<i> or wrong).
</I>&gt;<i>
</I>&gt;<i> One valid reason for not having req.write() flush data automatically
</I>&gt;<i> though is
</I>&gt;<i> if you are using an output filter that wants to see the whole data in
</I>&gt;<i> one go. An
</I>&gt;<i> example is the &quot;CONTENT_LENGTH&quot; filter. If you had configured your
</I>&gt;<i> handler
</I>&gt;<i> output to go through this filter, you could just say:
</I>&gt;<i>
</I>&gt;<i> def handler(req):
</I>&gt;<i>      data = 'No chunking involved.' * 1024
</I>&gt;<i>      req.write(data,0)
</I>&gt;<i>      req.write(data,0)
</I>&gt;<i>      ....
</I>&gt;<i>      return apache.OK
</I>&gt;<i>
</I>&gt;<i> and the output filter would add the content length header for you
</I>&gt;<i> automatically.
</I>&gt;<i> For this to work, you have to ensure that flush isn't called
</I>&gt;<i> explicitly or implicitly.
</I>&gt;<i>
</I>&gt;<i> What are the underlying concerns that make you think you need to
</I>&gt;<i> understand
</I>&gt;<i> this better?
</I>&gt;<i>
</I>&gt;<i> Graham
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mod_python mailing list
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020354.html">[mod_python] Re: Chunked encoding
</A></li>
	<LI>Next message: <A HREF="020356.html">[mod_python] Re: Chunked encoding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20355">[ date ]</a>
              <a href="thread.html#20355">[ thread ]</a>
              <a href="subject.html#20355">[ subject ]</a>
              <a href="author.html#20355">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
