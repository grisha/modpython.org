<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Re: Chunked encoding
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Re%3A%20Chunked%20encoding&In-Reply-To=4817b6fc0602182336y6603ae03k87f3312135230eb7%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020355.html">
   <LINK REL="Next"  HREF="020375.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Re: Chunked encoding</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Jim Gallacher</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Re%3A%20Chunked%20encoding&In-Reply-To=4817b6fc0602182336y6603ae03k87f3312135230eb7%40mail.gmail.com"
       TITLE="[mod_python] Re: Chunked encoding">jpg at jgassociates.ca
       </A><BR>
    <I>Sun Feb 19 11:43:00 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020355.html">[mod_python] Re: Chunked encoding
</A></li>
        <LI>Next message: <A HREF="020375.html">[mod_python] Re: Chunked encoding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20356">[ date ]</a>
              <a href="thread.html#20356">[ thread ]</a>
              <a href="subject.html#20356">[ subject ]</a>
              <a href="author.html#20356">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>req.write() is a pretty simple wrapper around the apache function 
ap_rwrite. Mod_python does not do any buffering itself. If you are 
curious take a look the req_write function in the mod_python source 
src/requestobject.c


For more info on chunked encoding see check RFC2616:

3.6.1 Chunked Transfer Coding

The chunked encoding modifies the body of a message in order to transfer
it as a series of chunks, each with its own size indicator, followed by
an OPTIONAL trailer containing entity-header fields. This allows
dynamically produced content to be transferred along with the
information necessary for the recipient to verify that it has received
the full message.

Jim

Dan Eloff wrote:
&gt;<i> Well mostly it's just my C++ days coming back to haunt me, can't stand the
</I>&gt;<i> thought of buffering large amounts of data for no reason at all. But it's
</I>&gt;<i> just a minor concern, and for now performance is a non-issue, I'll cross
</I>&gt;<i> that bridge when I get there. I was just wondering if there was a easy way
</I>&gt;<i> to write data from my string to the browser, but that may not even be
</I>&gt;<i> possible for all I know.
</I>&gt;<i> 
</I>&gt;<i> Thanks Graham.
</I>&gt;<i> -Dan
</I>&gt;<i> 
</I>&gt;<i> On 2/18/06, Graham Dumpleton &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">grahamd at dscpl.com.au</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>On 19/02/2006, at 9:14 AM, Dan Eloff wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>I'm curious about this &quot;chunked encoding&quot; what does that mean? I
</I>&gt;&gt;&gt;<i>output all my pages in my handler as a single string, so I have a
</I>&gt;&gt;&gt;<i>sort of interest in understanding what the write method does. If
</I>&gt;&gt;&gt;<i>I'm to take a wild guess at how the below works, you set the
</I>&gt;&gt;&gt;<i>content length so that mod_python realizes when it recieves your
</I>&gt;&gt;&gt;<i>data string that no more is coming and it doesn't need to copy the
</I>&gt;&gt;&gt;<i>string into a buffer, it can just keep a reference to it? And
</I>&gt;&gt;&gt;<i>somehow the act of buffering the data as opposed to writing it
</I>&gt;&gt;&gt;<i>immediately causes mod_python not to emply this &quot;chunked encoding&quot;?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>It'd be great if someone explained this to me :)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Thanks,
</I>&gt;&gt;&gt;<i>-Dan
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>On 2/15/06, Lars Eriksen &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">downgrade at gmx.org</A> &gt; wrote:Yes, there
</I>&gt;&gt;&gt;<i>is :-) RTFM, I guess ...
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>from mod_python.util import *
</I>&gt;&gt;&gt;<i>from mod_python import apache
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>def handle(req):
</I>&gt;&gt;&gt;<i>    data = 'No chunking involved.' * 1024
</I>&gt;&gt;&gt;<i>    req.set_content_length(len(data))
</I>&gt;&gt;&gt;<i>    req.write(data, 0)
</I>&gt;&gt;&gt;<i>    req.flush()
</I>&gt;&gt;&gt;<i>    return apache.OK
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>As far as I can tell, there is no difference between that and:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>def handler(req):
</I>&gt;&gt;<i>     data = 'No chunking involved.' * 1024
</I>&gt;&gt;<i>     req.set_content_length(len(data))
</I>&gt;&gt;<i>     req.write(data)
</I>&gt;&gt;<i>     return apache.OK
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>When no second argument is supplied to req.write(), it automatically
</I>&gt;&gt;<i>flushes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>In this particular case, since there is only one call to req.write(),
</I>&gt;&gt;<i>it is also
</I>&gt;&gt;<i>probably equivalent to:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>def handler(req):
</I>&gt;&gt;<i>     data = 'No chunking involved.' * 1024
</I>&gt;&gt;<i>     req.set_content_length(len(data))
</I>&gt;&gt;<i>     req.write(data,0)
</I>&gt;&gt;<i>     return apache.OK
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>That is, returning apache.OK is going to have the same effect of
</I>&gt;&gt;<i>flushing the
</I>&gt;&gt;<i>buffered data if there is any.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>FWIW, chunked encoding is only of relevance to HTTP/1.1 clients. You
</I>&gt;&gt;<i>as the
</I>&gt;&gt;<i>provider of the handler does not really have to care about it as
</I>&gt;&gt;<i>Apache will
</I>&gt;&gt;<i>worry about it and use it if the client is capable of handling HTTP/
</I>&gt;&gt;<i>1.1. That is,
</I>&gt;&gt;<i>mod_python doesn't do anything about chunked encoding either.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>As to the connection between req.set_content_length() and how much data
</I>&gt;&gt;<i>you write, there isn't really any. Calling req.set_content_length()
</I>&gt;&gt;<i>only has the
</I>&gt;&gt;<i>effect of setting the &quot;Content-Length&quot; response header. You could set
</I>&gt;&gt;<i>the
</I>&gt;&gt;<i>content length to a small value and write more data that you say
</I>&gt;&gt;<i>there will be
</I>&gt;&gt;<i>and mod_python/Apache will quite happily let you do it. A remote
</I>&gt;&gt;<i>client on
</I>&gt;&gt;<i>the other handle may well probably discard any extra content if it
</I>&gt;&gt;<i>honours the
</I>&gt;&gt;<i>content length header.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>For most people, how many times you call req.write() and whether you use
</I>&gt;&gt;<i>buffering isn't going to matter one bit. Some may want to minimise
</I>&gt;&gt;<i>the number
</I>&gt;&gt;<i>of calls to req.write() or use buffering for perceived performance
</I>&gt;&gt;<i>reasons (right
</I>&gt;&gt;<i>or wrong).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>One valid reason for not having req.write() flush data automatically
</I>&gt;&gt;<i>though is
</I>&gt;&gt;<i>if you are using an output filter that wants to see the whole data in
</I>&gt;&gt;<i>one go. An
</I>&gt;&gt;<i>example is the &quot;CONTENT_LENGTH&quot; filter. If you had configured your
</I>&gt;&gt;<i>handler
</I>&gt;&gt;<i>output to go through this filter, you could just say:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>def handler(req):
</I>&gt;&gt;<i>     data = 'No chunking involved.' * 1024
</I>&gt;&gt;<i>     req.write(data,0)
</I>&gt;&gt;<i>     req.write(data,0)
</I>&gt;&gt;<i>     ....
</I>&gt;&gt;<i>     return apache.OK
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>and the output filter would add the content length header for you
</I>&gt;&gt;<i>automatically.
</I>&gt;&gt;<i>For this to work, you have to ensure that flush isn't called
</I>&gt;&gt;<i>explicitly or implicitly.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>What are the underlying concerns that make you think you need to
</I>&gt;&gt;<i>understand
</I>&gt;&gt;<i>this better?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Graham
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mod_python mailing list
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020355.html">[mod_python] Re: Chunked encoding
</A></li>
	<LI>Next message: <A HREF="020375.html">[mod_python] Re: Chunked encoding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20356">[ date ]</a>
              <a href="thread.html#20356">[ thread ]</a>
              <a href="subject.html#20356">[ subject ]</a>
              <a href="author.html#20356">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
