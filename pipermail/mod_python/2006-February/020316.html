<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Problem with PSP and unicode
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Problem%20with%20PSP%20and%20unicode&In-Reply-To=43F4DA5B.20308%40dd.revealed.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020313.html">
   <LINK REL="Next"  HREF="020323.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Problem with PSP and unicode</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Nicolas Lehuen</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Problem%20with%20PSP%20and%20unicode&In-Reply-To=43F4DA5B.20308%40dd.revealed.net"
       TITLE="[mod_python] Problem with PSP and unicode">nicolas at lehuen.com
       </A><BR>
    <I>Thu Feb 16 15:31:52 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020313.html">[mod_python] Problem with PSP and unicode
</A></li>
        <LI>Next message: <A HREF="020323.html">[mod_python] Problem with PSP and unicode
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20316">[ date ]</a>
              <a href="thread.html#20316">[ thread ]</a>
              <a href="subject.html#20316">[ subject ]</a>
              <a href="author.html#20316">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Well, in fact, I'm not using PSP, but my own templating system. The
whole code is around 500 lines of pure Python. It uses a regular
expression based tokenizer, a recursive hand-written parser (the
grammar is simple enough), and the result of a template compilation is
an optimized (simplified) AST that is visited each time the template
needs to be evaluated (it is not Python code that gets compiled
afterwards, I don't feel the need to do so).

The template markup are close to those used in the Velocity Java
template engine, that is to say you cannot insert any Python code in
the template, you have to play by some rules as far as flow control is
concerned.

However, the evaluation tags can contain full Python evaluation, so
they are not as limited as the one you can find in Zope's TAL, Kid or
Django. I know they are limited on purpose, but I can't bear to be
forced to jump through hoops to please a development philosophy that
mostly gets in the way IMHO. There is no need to prevent your
developers to write full blown Python expression in their templates ;
if they have a little discipline, it is a real time saver.

The template are used by modules published by the
mod_python.publisher. Like it was mentioned in a thread a few weeks
ago, I use a Python decorator to specify that the dictionary returned
by a published function or method must be used with a given template -
the decorator handle all the fuss about computing the relative path of
the template, and calling the template cache.

All this is not perfect yet but I've been happily using it for nearly
a year now on various projects which are currently in production
(though under a quite moderate load so I cannot boast about its
performance apart that saying it is not a problem at all).

All this to say that yes, writing an efficient pure Python template is
possible, there already exists a zillion and if none please you, then
with about 500 lines of code you have something good enough. Now, why
should we have to maintain some fairly obscure C code for the PSP
module, that eludes me  :).

Regards,
Nicolas

2006/2/16, Nick &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">nick at dd.revealed.net</A>&gt;:
&gt;<i> Nicolas Lehuen wrote:
</I>&gt;<i> &gt; If it were up to me, I would reimplement it in pure Python, and I
</I>&gt;<i> &gt; don't think the performance loss would be so big. Granted, compilation
</I>&gt;<i> &gt; would be a little slower, but once the PSP is compiled, performance
</I>&gt;<i> &gt; should be exactly the same - and implementing a compiler cache is
</I>&gt;<i> &gt; extremely easy. Plus, the code being more easy to maintain, we could
</I>&gt;<i> &gt; easily optimize it. Call it &quot;doing it the PyPy way&quot; if you like ;).
</I>&gt;<i>
</I>&gt;<i> The original PSE parser I did worked very similar to PSP.  I used HTMLParser
</I>&gt;<i> in the standard lib to do it.  However, it was different in that it was not
</I>&gt;<i> PHP/ASP-ish where code could just be stuck anywhere; it had to be parsable
</I>&gt;<i> HTML.  But I suspect you could just use a regular expression to do what the
</I>&gt;<i> PSP parser does.
</I>&gt;<i>
</I>&gt;<i> Nick
</I>&gt;<i>
</I>
</PRE>

















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020313.html">[mod_python] Problem with PSP and unicode
</A></li>
	<LI>Next message: <A HREF="020323.html">[mod_python] Problem with PSP and unicode
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20316">[ date ]</a>
              <a href="thread.html#20316">[ thread ]</a>
              <a href="subject.html#20316">[ subject ]</a>
              <a href="author.html#20316">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
