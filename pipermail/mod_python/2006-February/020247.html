<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Re: forks, daemons, and other beasts
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Re%3A%20forks%2C%20daemons%2C%20and%20other%20beasts&In-Reply-To=5f56302b0602120303u685b877ck3f169fcb300d3224%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020246.html">
   <LINK REL="Next"  HREF="020289.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Re: forks, daemons, and other beasts</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Daniel J. Popowich</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Re%3A%20forks%2C%20daemons%2C%20and%20other%20beasts&In-Reply-To=5f56302b0602120303u685b877ck3f169fcb300d3224%40mail.gmail.com"
       TITLE="[mod_python] Re: forks, daemons, and other beasts">dpopowich at comcast.net
       </A><BR>
    <I>Sun Feb 12 15:00:55 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020246.html">[mod_python] Re: forks, daemons, and other beasts
</A></li>
        <LI>Next message: <A HREF="020289.html">[mod_python] ANNOUNCE: Mod_python 3.2.7
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20247">[ date ]</a>
              <a href="thread.html#20247">[ thread ]</a>
              <a href="subject.html#20247">[ subject ]</a>
              <a href="author.html#20247">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Daniel Nogradi writes:
&gt;<i> &gt; &gt;&gt;&gt;&gt; The documentation for thread says that
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; When the main thread exits, it is system defined whether the other
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; threads survive. On SGI IRIX using the native thread
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; implementation,
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; they survive. On most other systems, they are killed without
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; executing
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; try ... finally clauses or executing object destructors.
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; I tested this and indeed whatever is called with
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; thread.start_new_thread it will die if execution reaches the end of
</I>&gt;<i> &gt; &gt;&gt;&gt;&gt; the original program.
</I>&gt;<i> &gt; &gt;&gt;&gt;
</I>&gt;<i> &gt; &gt;&gt;&gt; This may be completely off, but how about sending the
</I>&gt;<i> &gt; &gt;&gt;&gt; notification, closing the connection to the client, then
</I>&gt;<i> &gt; &gt;&gt;&gt; unzipping in the same thread?
</I>&gt;<i> &gt; &gt;&gt;
</I>&gt;<i> &gt; &gt;&gt; I doubt the client socket connection would be closed off if one
</I>&gt;<i> &gt; &gt;&gt; did that
</I>&gt;<i> &gt; &gt;&gt; and if no content length was specified, the client browser would
</I>&gt;<i> &gt; &gt;&gt; probably
</I>&gt;<i> &gt; &gt;&gt; hang waiting for socket connection to close and thus would not
</I>&gt;<i> &gt; &gt;&gt; necessarily
</I>&gt;<i> &gt; &gt;&gt; render what it had already received. In other words, the content
</I>&gt;<i> &gt; &gt;&gt; handler
</I>&gt;<i> &gt; &gt;&gt; has to return for socket connection to get closed off. That is
</I>&gt;<i> &gt; &gt;&gt; also presuming
</I>&gt;<i> &gt; &gt;&gt; that keep alive is not enabled.
</I>&gt;<i> &gt; &gt;&gt;
</I>&gt;<i> &gt; &gt;&gt; Graham
</I>&gt;<i> &gt; &gt; I think you might've misunderstood what I meant, or else I said it
</I>&gt;<i> &gt; &gt; wrong. I'm talking about sending some data along, then manually
</I>&gt;<i> &gt; &gt; doing whatever the mod_python equivalent of shutdown(socket,
</I>&gt;<i> &gt; &gt; SHUT_RDWR) is, then performing what you need to do (in this case
</I>&gt;<i> &gt; &gt; unzipping). AFAIK, this guarantees that the connection is closed by
</I>&gt;<i> &gt; &gt; sending FIN, rather than the alternative, simply closing it (which
</I>&gt;<i> &gt; &gt; will leave the connection hanging if the fd is open in any other
</I>&gt;<i> &gt; &gt; threads or processes).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Another possibility is dumping the zip file into an incoming
</I>&gt;<i> &gt; &gt; directory, then having a cron job or scheduled task periodically
</I>&gt;<i> &gt; &gt; unzip any files in that directory. I don't know if this would work
</I>&gt;<i> &gt; &gt; for your application, though.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I knew what you meant. It simply isn't possible in mod_python/Apache
</I>&gt;<i> &gt; to say
</I>&gt;<i> &gt; shutdown the socket connection. There are potentially various layers
</I>&gt;<i> &gt; of Apache
</I>&gt;<i> &gt; filters and other stuff between the mod_python handler and the socket
</I>&gt;<i> &gt; and
</I>&gt;<i> &gt; mod_python doesn't have a direct handle on the socket that it can
</I>&gt;<i> &gt; manipulate.
</I>&gt;<i> &gt; Thus, in the context of mod_python, it isn't that simple.
</I>&gt;<i> 
</I>&gt;<i> One more thought: it seems that if MaxRequestsPerChild is 1, then
</I>&gt;<i> anything threaded from the script handling the request will die when
</I>&gt;<i> the script ends, but if MaxRequestsPerChild is N &gt; 1, then it doesn't
</I>&gt;<i> die, so everything seems to be okay. But what if the request is
</I>&gt;<i> exactly the Nth for that particular child, then it will be the same as
</I>&gt;<i> before, and the thread will die, won't it?
</I>

As has been discussed there are interoperability issues with apache if
you use spawn* calls, threading and I can't imagine what would happen
with exec* calls.

If you are on a unix system I think the easiest way to go is put your
post-processing in a script (a python script of course!) that traps
the TERM signal and then use the os.system() call in your handler.

For example, if you have this script, /tmp/foo.py:

    ############################################################
    # /tmp/foo.py

    import signal
    import time

    # ignore the TERM signal, so if apache kills the child process
    # that forked me I won't die.
    signal.signal(signal.SIGTERM, signal.SIG_IGN)

    # Your Code Here!
    # for this demo we'll sleep, so you have time to stop apache and
    # see this is still running
    time.sleep(30)

    # some output to prove we ran
    print &quot;hello, world&quot;

    #
    ############################################################


Then in your handler:

    os.system('python /tmp/foo.py &gt;&amp; /tmp/foo.log &amp;')

If you're not familiar with unix: the above executes the script as if
you typed it in a terminal running a shell.  Stdout and stderr are
redirected to /tmp/foo.log, else they will be inherited from apache's,
which is probably not what we want.  The trailing ampersand will put
the job in the background, detaching from the parent process.

Hope this helps!

Daniel Popowich
---------------
<A HREF="http://home.comcast.net/~d.popowich/mpservlets/">http://home.comcast.net/~d.popowich/mpservlets/</A>
</PRE>





















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020246.html">[mod_python] Re: forks, daemons, and other beasts
</A></li>
	<LI>Next message: <A HREF="020289.html">[mod_python] ANNOUNCE: Mod_python 3.2.7
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20247">[ date ]</a>
              <a href="thread.html#20247">[ thread ]</a>
              <a href="subject.html#20247">[ subject ]</a>
              <a href="author.html#20247">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
