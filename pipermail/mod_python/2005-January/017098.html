<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Cookie patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Cookie%20patch&In-Reply-To=c298f2d7050113094866ad223c%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017097.html">
   <LINK REL="Next"  HREF="017099.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Cookie patch</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Craig Warren</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Cookie%20patch&In-Reply-To=c298f2d7050113094866ad223c%40mail.gmail.com"
       TITLE="[mod_python] Cookie patch">craig.warren at encorp.com
       </A><BR>
    <I>Thu Jan 13 14:44:36 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="017097.html">[mod_python] Cookie patch
</A></li>
        <LI>Next message: <A HREF="017099.html">[mod_python] Cookie patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17098">[ date ]</a>
              <a href="thread.html#17098">[ thread ]</a>
              <a href="subject.html#17098">[ subject ]</a>
              <a href="author.html#17098">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Skipped content of type multipart/alternative-------------- next part --------------
 #
 # Copyright 2004 Apache Software Foundation 
 # 
 # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you
 # may not use this file except in compliance with the License.  You
 # may obtain a copy of the License at
 #
 #      <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 # implied.  See the License for the specific language governing
 # permissions and limitations under the License.
 #
 # Originally developed by Gregory Trubetskoy.
 #
 # $Id: Cookie.py,v 1.11 2004/02/16 19:47:27 grisha Exp $

&quot;&quot;&quot;

This module contains classes to support HTTP State Management
Mechanism, also known as Cookies. The classes provide simple
ways for creating, parsing and digitally signing cookies, as
well as the ability to store simple Python objects in Cookies
(using marshalling).

The behaviour of the classes is designed to be most useful
within mod_python applications.

The current state of HTTP State Management standardization is
rather unclear. It appears that the de-facto standard is the
original Netscape specification, even though already two RFC's
have been put out (RFC2109 (1997) and RFC2965 (2000)). The
RFC's add a couple of useful features (e.g. using Max-Age instead
of Expires, but my limited tests show that Max-Age is ignored
by the two browsers tested (IE and Safari). As a result of this,
perhaps trying to be RFC-compliant (by automatically providing
Max-Age and Version) could be a waste of cookie space...

&quot;&quot;&quot;

import time
import re
import hmac
import marshal
import base64

#import apache

class CookieError(Exception):
    pass

class metaCookie(type):

    def __new__(cls, clsname, bases, clsdict):

        _valid_attr = (
            &quot;version&quot;, &quot;path&quot;, &quot;domain&quot;, &quot;secure&quot;,
            &quot;comment&quot;, &quot;expires&quot;, &quot;max_age&quot;,
            # RFC 2965
            &quot;commentURL&quot;, &quot;discard&quot;, &quot;port&quot;,)

       # _valid_attr + property values
        # (note __slots__ is a new Python feature, it
        # prevents any other attribute from being set)
        __slots__ = _valid_attr + (&quot;name&quot;, &quot;value&quot;, &quot;_value&quot;,
                                   &quot;_expires&quot;, &quot;__data__&quot;)

        clsdict[&quot;_valid_attr&quot;] = _valid_attr
        clsdict[&quot;__slots__&quot;] = __slots__

        def set_expires(self, value):

            if type(value) == type(&quot;&quot;):
                # if it's a string, it should be
                # valid format as per Netscape spec
                try:
                    t = time.strptime(value, &quot;%a, %d-%b-%Y %H:%M:%S GMT&quot;)
                except ValueError:
                    raise ValueError, &quot;Invalid expires time: %s&quot; % value
                t = time.mktime(t)
            else:
                # otherwise assume it's a number
                # representing time as from time.time()
                t = value
                value = time.strftime(&quot;%a, %d-%b-%Y %H:%M:%S GMT&quot;,
                                      time.gmtime(t))

            self._expires = &quot;%s&quot; % value

        def get_expires(self):
            return self._expires

        clsdict[&quot;expires&quot;] = property(fget=get_expires, fset=set_expires)

        return type.__new__(cls, clsname, bases, clsdict)

class Cookie(object):
    &quot;&quot;&quot;
    This class implements the basic Cookie functionality. Note that
    unlike the Python Standard Library Cookie class, this class represents
    a single cookie (not a list of Morsels).
    &quot;&quot;&quot;

    __metaclass__ = metaCookie

    def parse(Class, str):
        &quot;&quot;&quot;
        Parse a Cookie or Set-Cookie header value, and return
        a dict of Cookies. Note: the string should NOT include the
        header name, only the value.
        &quot;&quot;&quot;

        dict = _parse_cookie(str, Class)
        return dict

    parse = classmethod(parse)

    def __init__(self, name, value, **kw):

        &quot;&quot;&quot;
        This constructor takes at least a name and value as the
        arguments, as well as optionally any of allowed cookie attributes
        as defined in the existing cookie standards. 
        &quot;&quot;&quot;
        self.name, self.value = name, value

        for k in kw:
            setattr(self, k.lower(), kw[k])

        # subclasses can use this for internal stuff
        self.__data__ = {}


    def __str__(self):

        &quot;&quot;&quot;
        Provides the string representation of the Cookie suitable for
        sending to the browser. Note that the actual header name will
        not be part of the string.

        This method makes no attempt to automatically double-quote
        strings that contain special characters, even though the RFC's
        dictate this. This is because doing so seems to confuse most
        browsers out there.
        &quot;&quot;&quot;
        
        result = [&quot;%s=%s&quot; % (self.name, self.value)]
        for name in self._valid_attr:
            if hasattr(self, name):
                if name in (&quot;secure&quot;, &quot;discard&quot;):
                    result.append(name)
                else:
                    result.append(&quot;%s=%s&quot; % (name, getattr(self, name)))
        return &quot;; &quot;.join(result)
    
    def __repr__(self):
        return '&lt;%s: %s&gt;' % (self.__class__.__name__,
                                str(self))
    

class SignedCookie(Cookie):
    &quot;&quot;&quot;
    This is a variation of Cookie that provides automatic
    cryptographic signing of cookies and verification. It uses
    the HMAC support in the Python standard library. This ensures
    that the cookie has not been tamprered with on the client side.

    Note that this class does not encrypt cookie data, thus it
    is still plainly visible as part of the cookie.
    &quot;&quot;&quot;

    def parse(Class, s, secret):

        dict = _parse_cookie(s, Class)

        for k in dict:
            c = dict[k]
            try:
                c.unsign(secret)
            except CookieError:
                # downgrade to Cookie
                dict[k] = Cookie.parse(Cookie.__str__(c))[k]
        
        return dict

    parse = classmethod(parse)

    def __init__(self, name, value, secret=None, **kw):
        Cookie.__init__(self, name, value, **kw)

        self.__data__[&quot;secret&quot;] = secret

    def hexdigest(self, str):
        if not self.__data__[&quot;secret&quot;]:
            raise CookieError, &quot;Cannot sign without a secret&quot;
        _hmac = hmac.new(self.__data__[&quot;secret&quot;], self.name)
        _hmac.update(str)
        return _hmac.hexdigest()

    def __str__(self):
        
        result = [&quot;%s=%s%s&quot; % (self.name, self.hexdigest(self.value),
                               self.value)]
        for name in self._valid_attr:
            if hasattr(self, name):
                if name in (&quot;secure&quot;, &quot;discard&quot;):
                    result.append(name)
                else:
                    result.append(&quot;%s=%s&quot; % (name, getattr(self, name)))
        return &quot;; &quot;.join(result)

    def unsign(self, secret):

        sig, val = self.value[:32], self.value[32:]

        mac = hmac.new(secret, self.name)
        mac.update(val)

        if mac.hexdigest() == sig:
            self.value = val
            self.__data__[&quot;secret&quot;] = secret
        else:
            raise CookieError, &quot;Incorrectly Signed Cookie: %s=%s&quot; % (self.name, self.value)


class MarshalCookie(SignedCookie):

    &quot;&quot;&quot;
    This is a variation of SignedCookie that can store more than
    just strings. It will automatically marshal the cookie value,
    therefore any marshallable object can be used as value.

    The standard library Cookie module provides the ability to pickle
    data, which is a major security problem. It is believed that unmarshalling
    (as opposed to unpickling) is safe, yet we still err on the side of caution
    which is why this class is a subclass of SignedCooke making sure what
    we are about to unmarshal passes the digital signature test.

    Here is a link to a sugesstion that marshalling is safer than unpickling
    <A HREF="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;selm=7xn0hcugmy.fsf%40ruckus.brouhaha.com">http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;selm=7xn0hcugmy.fsf%40ruckus.brouhaha.com</A>
    &quot;&quot;&quot;

    def parse(Class, s, secret):

        dict = _parse_cookie(s, Class)

        for k in dict:
            c = dict[k]
            try:
                c.unmarshal(secret)
            except (CookieError, ValueError):
                # downgrade to Cookie
                dict[k] = Cookie.parse(Cookie.__str__(c))[k]

        return dict

    parse = classmethod(parse)

    def __str__(self):
        
        m = base64.encodestring(marshal.dumps(self.value))[:-1]

        result = [&quot;%s=%s%s&quot; % (self.name, self.hexdigest(m), m)]
        for name in self._valid_attr:
            if hasattr(self, name):
                if name in (&quot;secure&quot;, &quot;discard&quot;):
                    result.append(name)
                else:
                    result.append(&quot;%s=%s&quot; % (name, getattr(self, name)))
        return &quot;; &quot;.join(result)

    def unmarshal(self, secret):

        self.unsign(secret)
        self.value = marshal.loads(base64.decodestring(self.value))



# This is a simplified and in some places corrected
# (at least I think it is) pattern from standard lib Cookie.py

_cookiePattern = re.compile(
    r&quot;(?x)&quot;                       # Verbose pattern
    r&quot;[,\ ]*&quot;                        # space/comma (RFC2616 4.2) before attr-val is eaten
    r&quot;(?P&lt;key&gt;&quot;                   # Start of group 'key'
    r&quot;[^;\ =]+&quot;                     # anything but ';', ' ' or '='
    r&quot;)&quot;                          # End of group 'key'
    r&quot;\ *(=\ *)?&quot;                 # a space, then may be &quot;=&quot;, more space
    r&quot;(?P&lt;val&gt;&quot;                   # Start of group 'val'
    r'&quot;(?:[^\\&quot;]|\\.)*&quot;'            # a doublequoted string
    r&quot;|&quot;                            # or
    r&quot;[^;]*&quot;                        # any word or empty string
    r&quot;)&quot;                          # End of group 'val'
    r&quot;\s*;?&quot;                      # probably ending in a semi-colon
    )

def _parse_cookie(str, Class):
    # XXX problem is we should allow duplicate
    # strings
    result = {}
    all_cookies_attribute = {}

    valid = Cookie._valid_attr

    c = None
    matchIter = _cookiePattern.finditer(str)

    for match in matchIter:

        key, val = match.group(&quot;key&quot;), match.group(&quot;val&quot;)

        # we will check whether the cookie name is a valid attribute name
        # for the previous cookie.
        l_key = key.lower()
        # fix from Craig Warren
        if l_key[0]=='$':
            l_key=l_key[1:]
        if l_key == &quot;max-age&quot;:
            l_key = &quot;max_age&quot;
        
        if l_key in valid:
            if not c:
                # 'global' attribute, will be added to all cookies
                all_cookies_attribute[l_key]=val
            else:
                # &quot;internal&quot; attribute, add to cookie
                setattr(c, l_key, val)
        else:
            # start a new cookie
            # we don't use l_key so that we keep the initial name
            # this way we are consistent with the creation of the first cookie
            # as done in the previous version of the function
            c = Class(key, val)

            # XXX this is a bit heavyweight since usually we'll have only 0 or 1
            # global attribute...
            for key, val in all_cookies_attribute.items():
                setattr(c,key,val)

            result[key] = c

    return result


def _parse_cookie_new(str, Class):
    # XXX problem is we should allow duplicate
    # strings
    result = {}
    all_cookies_attribute = {}

    valid = Cookie._valid_attr

    c = None
    matchIter = _cookiePattern.finditer(str)

    for match in matchIter:

        key, val = match.group(&quot;key&quot;), match.group(&quot;val&quot;)

        # we will check whether the cookie name is a valid attribute name
        # for the previous cookie.
        l_key = key.lower()
        # fix from Craig Warren
        if l_key[0]=='$':
            l_key=l_key[1:]
        if l_key == &quot;max-age&quot;:
            l_key = &quot;max_age&quot;

        c = Class(key,l_key)
        
        if l_key in valid:
            if key[0] == '$':
                all_cookies_attribute[l_key]=val
            elif c == None:
                c = Class(key,l_key)
            else:
                setattr(c, l_key, val)
        else:
            # start a new cookie
            # we don't use l_key so that we keep the initial name
            # this way we are consistent with the creation of the first cookie
            # as done in the previous version of the function
            c = Class(key, val)

            # XXX this is a bit heavyweight since usually we'll have only 0 or 1
            # global attribute...
            for key, val in all_cookies_attribute.items():
                setattr(c,key,val)

            result[key] = c

    return result

def _parse_cookie_my(str, Class):

    # XXX problem is we should allow duplicate
    # strings
    result = {}

    # max-age is a problem because of the '-'
    # XXX there should be a more elegant way
    valid = Cookie._valid_attr + (&quot;max-age&quot;,)

    c = None
    matchIter = _cookiePattern.finditer(str)

    for match in matchIter:

        key, val = match.group(&quot;key&quot;), match.group(&quot;val&quot;)

        if not c:
            # new cookie
            c = Class(key, val)
            result[key] = c

        l_key = key.lower()
        
        if (l_key in valid or key[0] == '$'):
            
            # &quot;internal&quot; attribute, add to cookie

            if l_key == &quot;max-age&quot;:
                l_key = &quot;max_age&quot;
            if key[0] == '$':
                l_key = l_key[1:]
            setattr(c, l_key, val)

        else:
            # start a new cookie
            c = Class(l_key, val)
            result[l_key] = c

    return result

def add_cookie(req, cookie, value=&quot;&quot;, **kw):
    &quot;&quot;&quot;
    Sets a cookie in outgoing headers and adds a cache
    directive so that caches don't cache the cookie.
    &quot;&quot;&quot;

    # is this a cookie?
    if not isinstance(cookie, Cookie):

        # make a cookie
        cookie = Cookie(cookie, value, **kw)
        
    if not req.headers_out.has_key(&quot;Set-Cookie&quot;):
        req.headers_out.add(&quot;Cache-Control&quot;, 'no-cache=&quot;set-cookie&quot;')

    req.headers_out.add(&quot;Set-Cookie&quot;, str(cookie))

def get_cookies(req, Class=Cookie, **kw):
    &quot;&quot;&quot;
    A shorthand for retrieveing and parsing cookies given
    a Cookie class. The class must be one of the classes from
    this module.
    &quot;&quot;&quot;
    
    if not req.headers_in.has_key(&quot;cookie&quot;):
        return {}

    cookies = req.headers_in[&quot;cookie&quot;]
    if type(cookies) == type([]):
        cookies = '; '.join(cookies)

    return Class.parse(cookies, **kw)

-------------- next part --------------
from Cookie import _parse_cookie,_parse_cookie_my,Cookie

def print_cookies(c):
    print 'Cookies'
    for k in c.keys():
        print c[k]
    print 

c1 = 'test=1;bob=1;$Version=0;$Path=/'
c2 = '$Version=0;$Path=/;test=1'
c3 = 'test=1;$Version=0;bob=1;$Path=/'

tests = [c1,c2,c3]
for t in tests:
    c = _parse_cookie(t,Cookie)
    print 'TEST'
    print ' --------------------------------------------------'
    print 'New Funtion'
    print 'Cookie:%s' % t
    print_cookies(c)

    c = _parse_cookie_my(t,Cookie)
    print 'My function Old with my fix'
    print 'Cookie:%s' % t
    print_cookies(c)
    print ' --------------------------------------------------'
    print



</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017097.html">[mod_python] Cookie patch
</A></li>
	<LI>Next message: <A HREF="017099.html">[mod_python] Cookie patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17098">[ date ]</a>
              <a href="thread.html#17098">[ thread ]</a>
              <a href="subject.html#17098">[ subject ]</a>
              <a href="author.html#17098">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
