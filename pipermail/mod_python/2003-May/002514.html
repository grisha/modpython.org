<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] [Patch] req.write_file for 3.0.x
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20%5BPatch%5D%20req.write_file%20for%203.0.x&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002512.html">
   <LINK REL="Next"  HREF="002515.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] [Patch] req.write_file for 3.0.x</H1>
    <B>Conrad Steenberg</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20%5BPatch%5D%20req.write_file%20for%203.0.x&In-Reply-To="
       TITLE="[mod_python] [Patch] req.write_file for 3.0.x">conrad at hep.caltech.edu
       </A><BR>
    <I>Tue May  6 01:36:26 EST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="002512.html">[mod_python] FreeBSD/Apache2/mod_python3.0.3 install issue
</A></li>
        <LI>Next message: <A HREF="002515.html">[mod_python] [Patch] req.write_file for 3.0.x
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2514">[ date ]</a>
              <a href="thread.html#2514">[ thread ]</a>
              <a href="subject.html#2514">[ subject ]</a>
              <a href="author.html#2514">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi

Attached is a patch (against 3.0.1 but probably works for all 3.0.x) for
src/requestobject.c to allow mod_python programs to send files
efficiently using the available Apache machinery for both unencrypted
and SSL/TLS connections.

What does it do?
----------------

Implements a file_write() method for the Request object. It does NOT
write headers, only the file.

E.g.

def handler(req):
  req.content_type='text/html'
  req.send_http_header()
  sent=0
  while 
  req.write_file(&quot;/var/www/html/index.html&quot;,0,-1)
  return apache.OK

The first argument is the filename, the second is the offset to start
reading in the file, the third argument is the number of bytes to write.
The last two arguments are optional.

The return value is the number of bytes written, which may be less than
the total number of bytes in the file. See the manpage of sendfile for
more details.

The patch is NOT OS- or architecture dependent, it merely lets Apache
call its output handler, in the same way that req.write() does for
string data.

If there is interest, the patch can developed further to also set the
content-type, send headers and iterate until the whole file is sent.

Cheers

Conrad
-- 
Conrad Steenberg &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">conrad at hep.caltech.edu</A>&gt;
-------------- next part --------------
--- requestobject.c.orig	2003-05-05 12:13:07.000000000 -0700
+++ requestobject.c	2003-05-05 13:34:50.000000000 -0700
@@ -808,6 +808,54 @@
 
 }
 
+static PyObject * req_write_file(requestobject *self, PyObject *args)
+{
+    int rc;
+    char *fname;
+    apr_file_t *fd;
+    apr_size_t offset=0, len=-1, nbytes;
+    apr_status_t status;
+    PyObject * py_result = NULL;
+    apr_finfo_t finfo;
+    
+    
+    if (! PyArg_ParseTuple(args, &quot;s|ll&quot;, &amp;fname, &amp;offset, &amp;len))
+        return NULL;  /* bad args */
+
+    status=apr_stat(&amp;finfo, fname,
+                    APR_READ, self-&gt;request_rec-&gt;pool);
+    if (status != APR_SUCCESS) {
+        PyErr_SetString(PyExc_IOError, &quot;Could not stat file for reading&quot;);
+        return NULL;
+    }
+    
+    status=apr_file_open(&amp;fd, fname,
+                         APR_READ, finfo.protection,
+                         self-&gt;request_rec-&gt;pool);
+    if (status != APR_SUCCESS) {
+        PyErr_SetString(PyExc_IOError, &quot;Could not open file for reading&quot;);
+        return NULL;
+    }                         
+
+    if (len==-1) len=finfo.size;
+        
+    Py_BEGIN_ALLOW_THREADS                         
+    status = ap_send_fd(fd, self-&gt;request_rec, offset, 
+             len, &amp;nbytes);
+    
+    Py_END_ALLOW_THREADS
+    
+    if (status != APR_SUCCESS) {
+        PyErr_SetString(PyExc_IOError, &quot;Write failed, client closed connection.&quot;);
+        return NULL;
+    }
+
+    py_result = PyLong_FromLong (nbytes);
+    Py_INCREF(py_result);
+    return py_result;
+
+}
+
 static PyMethodDef request_methods[] = {
     {&quot;add_common_vars&quot;,       (PyCFunction) req_add_common_vars,       METH_NOARGS},
     {&quot;add_handler&quot;,           (PyCFunction) req_add_handler,           METH_VARARGS},
@@ -827,6 +875,7 @@
     {&quot;send_http_header&quot;,      (PyCFunction) req_send_http_header,      METH_NOARGS},
     {&quot;set_content_length&quot;,    (PyCFunction) req_set_content_length,    METH_VARARGS},
     {&quot;write&quot;,                 (PyCFunction) req_write,                 METH_VARARGS},
+    {&quot;write_file&quot;,            (PyCFunction) req_write_file,            METH_VARARGS},
     { NULL, NULL } /* sentinel */
 };
 
</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002512.html">[mod_python] FreeBSD/Apache2/mod_python3.0.3 install issue
</A></li>
	<LI>Next message: <A HREF="002515.html">[mod_python] [Patch] req.write_file for 3.0.x
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2514">[ date ]</a>
              <a href="thread.html#2514">[ thread ]</a>
              <a href="subject.html#2514">[ subject ]</a>
              <a href="author.html#2514">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
