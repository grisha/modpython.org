<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Mod_Python, multicore and concurrency
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Mod_Python%2C%20multicore%20and%20concurrency&In-Reply-To=4A2275B0.2050208%40kickstone.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026227.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Mod_Python, multicore and concurrency</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Mod_Python%2C%20multicore%20and%20concurrency&In-Reply-To=4A2275B0.2050208%40kickstone.com"
       TITLE="[mod_python] Mod_Python, multicore and concurrency">graham.dumpleton at gmail.com
       </A><BR>
    <I>Sun May 31 20:58:05 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="026227.html">[mod_python] Session deadlocking in Linux but not Windows
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26230">[ date ]</a>
              <a href="thread.html#26230">[ thread ]</a>
              <a href="subject.html#26230">[ subject ]</a>
              <a href="author.html#26230">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2009/5/31 John Lister &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">john.lister at kickstone.com</A>&gt;:
&gt;<i> Graham Dumpleton wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you are using mod_python sessions at the same time, they will block
</I>&gt;&gt;<i> another request using same session at the same time. It can also block
</I>&gt;&gt;<i> other distinct sessions as well because of the limited number of
</I>&gt;&gt;<i> shared locks used to mediate global session locking.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers, just noticed your blog and having a read about apache processes and
</I>&gt;<i> mod_python. I still have a couple of questions - which may in part be due to
</I>&gt;<i> my confusion:
</I>&gt;<i> You blog states that the parent apache process initialises the python
</I>&gt;<i> interpreter, does mod_python therefore run in the main apache process with a
</I>&gt;<i> number of sub-interpreters and the child apache processes farm off requests
</I>&gt;<i> to this one? Or does each child apache process get its own couple of a
</I>&gt;<i> python interpreter - which is what i thought and other parts of your blog
</I>&gt;<i> seem to suggest this.
</I>
The main Python interpreter is initialised within the parent. That is
inherited by child processes when Apache forks its child server
processes. Any additional sub interpreters as required, are then only
created within the context of the child server processes. All Python
request handling occurs in the child server processes.

&gt;<i> I'm not sure what you mean by session above.
</I>
I specifically mean if you were using the Session class provided with
mod_python directly, or indirectly by using 'session' attribute in a
PSP page.

&gt;<i> For example say i have a quad
</I>&gt;<i> core system with the default apache settings for pre-fork and i make 4
</I>&gt;<i> distinct requests for a python page at the same time, am i wrong to think
</I>&gt;<i> that 4 child processes will run (ideally one per core) . At the moment i see
</I>&gt;<i> a spike on all the cores for the first request, but if i repeat the above,
</I>&gt;<i> only one core seems to be maxed out at 100%.
</I>
All I can suggest to try and debug relationships between requests by
printing out to the error log the time of the request, the os.getpid()
of the process handling the request and the Apache req.connection.id
of the inbound connection. The latter to ascertain whether keep alive
connections may be part of the issue.

Graham

&gt;&gt;<i> Other than that guess, it is impossible to answer without know exactly
</I>&gt;&gt;<i> what your code does.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The code is relatively straightforward in that it does a series of cpu bound
</I>&gt;<i> calculations before returning the result. These generally take in the order
</I>&gt;<i> of seconds rather than milliseconds which is why i'd like to spread them
</I>&gt;<i> across multiple cores, the handler is something like this:
</I>&gt;<i>
</I>&gt;<i> def handler(req):
</I>&gt;<i> &#160; html=generateHtml()
</I>&gt;<i> &#160; req.write(html)
</I>&gt;<i> &#160; return apache.OK
</I>&gt;<i>
</I>&gt;<i> Thanks
</I>&gt;<i>
</I>&gt;<i> JOHN
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026227.html">[mod_python] Session deadlocking in Linux but not Windows
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26230">[ date ]</a>
              <a href="thread.html#26230">[ thread ]</a>
              <a href="subject.html#26230">[ subject ]</a>
              <a href="author.html#26230">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
