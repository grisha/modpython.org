<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Building a web application using Cheetah and
	mod_python
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Building%20a%20web%20application%20using%20Cheetah%20and%0A%09mod_python&In-Reply-To=D5AA0517-7159-4D8F-9C09-092AC060608A%40dscpl.com.au">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022420.html">
   <LINK REL="Next"  HREF="022411.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Building a web application using Cheetah and
	mod_python</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Dirk van Oosterbosch, IR labs</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Building%20a%20web%20application%20using%20Cheetah%20and%0A%09mod_python&In-Reply-To=D5AA0517-7159-4D8F-9C09-092AC060608A%40dscpl.com.au"
       TITLE="[mod_python] Building a web application using Cheetah and
	mod_python">labs at ixopusada.com
       </A><BR>
    <I>Mon Oct 30 20:14:06 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="022420.html">[mod_python] Building a web application using Cheetah and
	mod_python
</A></li>
        <LI>Next message: <A HREF="022411.html">[mod_python] Caching pages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22435">[ date ]</a>
              <a href="thread.html#22435">[ thread ]</a>
              <a href="subject.html#22435">[ subject ]</a>
              <a href="author.html#22435">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks,

&gt;<i> Using current versions of mod_python available there is no way of  
</I>&gt;<i> doing it except
</I>&gt;<i> perhaps by using the Vampire extensions for mod_python.  
</I>&gt;<i> Alternatively, use
</I>&gt;<i> version 3.3 of mod_python out of Subversion repository or wait  
</I>&gt;<i> until it is released.
</I>&gt;<i>
</I>&gt;<i> [...]
</I>&gt;<i>
</I>&gt;<i> This works even if 'from bar import bar' is used as they intercept  
</I>&gt;<i> the 'import'
</I>&gt;<i> statement and when an import is performed from inside a module  
</I>&gt;<i> which was
</I>&gt;<i> already imported using the module importer, it will use the module  
</I>&gt;<i> importer for
</I>&gt;<i> the 'import' as well. Ie., no need to use apache.import_module()  
</I>&gt;<i> explicitly. If the
</I>&gt;<i> module being imported using 'import' is in another directory  
</I>&gt;<i> though, it is necessary
</I>&gt;<i> to specify an option declaring the search path for the modules.  
</I>&gt;<i> This is a path which
</I>&gt;<i> is distinct from PythonPath as new importer will not use any module  
</I>&gt;<i> in PythonPath
</I>&gt;<i> as a candidate for reloading as that causes lots of problems.
</I>
Then, I guess it won't do it's magic for __import__(modulename)  :-(
The way I am building my system, I'll need to call
	module = __import__(modulename, globals(), locals(), [name])
since I don't know the name of the module (and of the object) until  
runtime.
Will there be a cure for this too?

(I wouldn't have a problem so much with issuing a special command to  
make mod_python reload all modules, if it just wasn't &quot;apachectl  
stop ... apachectl start&quot; ;)


&gt;&gt;&gt;<i> Using '/' in the module name like this is not portable and is  
</I>&gt;&gt;&gt;<i> dependent
</I>&gt;&gt;&gt;<i> on peculiarities of the behaviour of Python on a specific  
</I>&gt;&gt;&gt;<i> platform. It will
</I>&gt;&gt;&gt;<i> not for example work on Mac OS X and also possibly not on Windows.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am working on a mac and also using slashes `/` to delimit my  
</I>&gt;&gt;<i> paths, so no problems there. (Didn't try from mod_python though &amp;  
</I>&gt;&gt;<i> dunno what will happen on Windows).
</I>&gt;<i>
</I>&gt;<i> What version of Python are you using? I know for sure it didn't  
</I>&gt;<i> work with
</I>&gt;<i> Python (2.3) on Panther. I also don't think it worked with Python  
</I>&gt;<i> (2.3.5)
</I>&gt;<i> on Tiger. If you are using Python 2.4 or later which you installed  
</I>&gt;<i> yourself,
</I>&gt;<i> it is entirely possible it may work.
</I>
Indeed, python 2.4.1


&gt;&gt;<i> I'm using os.path.join()
</I>&gt;<i>
</I>&gt;<i> Depending on the source of the path, one should actually use  
</I>&gt;<i> posixpath functions
</I>&gt;<i> sometimes instead of os.path. This is especially the case of  
</I>&gt;<i> working on req.uri and
</I>&gt;<i> sometimes on req.filename. This is because Apache supplies both of  
</I>&gt;<i> them as
</I>&gt;<i> POSIXish style paths and using os.path functions on Windows can  
</I>&gt;<i> screw things
</I>&gt;<i> up as it introduces back slashes.
</I>
I am not planning to port, but thanks for the tip!


Thanks again ... and mod_python 3.3 will be announced on this list  
won't it? ;-)

dirk





-----------------------------
Dirk van Oosterbosch
de Wittenstraat 225
1052 AT Amsterdam
the Netherlands

<A HREF="http://labs.ixopusada.com">http://labs.ixopusada.com</A>
-----------------------------


On 29-okt-2006, at 1:10, Graham Dumpleton wrote:

&gt;<i>
</I>&gt;<i> On 29/10/2006, at 4:12 AM, Dirk van Oosterbosch, IR labs wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am also working on a &quot;cms&quot;-like website system, using mod_python  
</I>&gt;&gt;<i> and Cheetah, though I've not yet tied these both up together, to  
</I>&gt;&gt;<i> be fully functional. Still working on the smaller subparts of the  
</I>&gt;&gt;<i> system.
</I>&gt;&gt;<i> So I follow this subject with great interest.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It feels like the core of this discussion is about making sure the  
</I>&gt;&gt;<i> cheetah modules gets reloaded when they change. I didn't conduct  
</I>&gt;&gt;<i> any tests yet, still trying to grasp the exact mechanisms underneath.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> [...]
</I>&gt;&gt;&gt;&gt;<i> Is this the best way to import template modules and then  
</I>&gt;&gt;&gt;&gt;<i> evaluate them?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> No, in as much as you are having to create a parallel hierarchy  
</I>&gt;&gt;&gt;<i> of publisher
</I>&gt;&gt;&gt;<i> handlers for each Cheetah page. You would be better off using a  
</I>&gt;&gt;&gt;<i> custom
</I>&gt;&gt;&gt;<i> handler which does the dispatch direct to the compiled Cheetah  
</I>&gt;&gt;&gt;<i> template
</I>&gt;&gt;&gt;<i> classes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not sure if this helps, but I've got a similar setup. There is  
</I>&gt;&gt;<i> one handler in a main.py that handles all requests. This main  
</I>&gt;&gt;<i> connects to a database, to find out which Cheetah template to use,  
</I>&gt;&gt;<i> and loads and fills this template. Also I've got a directory which  
</I>&gt;&gt;<i> hold all the python files directly necessary for the system (/var/ 
</I>&gt;&gt;<i> www/python) and an other directory to hold my templates. (/var/www/ 
</I>&gt;&gt;<i> python/templates)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If inside this main.py I would use an `apache.import_module 
</I>&gt;&gt;<i> (fooTemplate)` instead of just `from fooTemplate import  
</I>&gt;&gt;<i> fooTemplate`, that would mean that the fooTemplate is reloaded if  
</I>&gt;&gt;<i> it changed, doesn't it?
</I>&gt;<i>
</I>&gt;<i> Probably not. See issue 8 in:
</I>&gt;<i>
</I>&gt;<i>   <A HREF="http://www.dscpl.com.au/wiki/ModPython/Articles/">http://www.dscpl.com.au/wiki/ModPython/Articles/</A> 
</I>&gt;<i> ModuleImportingIsBroken
</I>&gt;<i>
</I>&gt;&gt;<i> But would it also mean that all the other templates which are  
</I>&gt;&gt;<i> imported through their inheritance would be reloaded if they are  
</I>&gt;&gt;<i> changed?
</I>&gt;<i>
</I>&gt;<i> Again, probably not, for same reason.
</I>&gt;<i>
</I>&gt;&gt;<i> Most of my templates are inheriting parent-templates using the  
</I>&gt;&gt;<i> Cheetah standard
</I>&gt;&gt;<i> #from bar import bar
</I>&gt;&gt;<i> #extends bar
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It's easy to create a whole directory with fresh modules, using  
</I>&gt;&gt;<i> the shell `cheetah compile *.tmpl`. But is there also a way to  
</I>&gt;&gt;<i> ensure me that apache is reloading them, if I do that? (i.e. an  
</I>&gt;&gt;<i> other way than restarting apache, which I have to do frequently  
</I>&gt;&gt;<i> while debugging this system :-(
</I>&gt;<i>
</I>&gt;<i> Using current versions of mod_python available there is no way of  
</I>&gt;<i> doing it except
</I>&gt;<i> perhaps by using the Vampire extensions for mod_python.  
</I>&gt;<i> Alternatively, use
</I>&gt;<i> version 3.3 of mod_python out of Subversion repository or wait  
</I>&gt;<i> until it is released.
</I>&gt;<i>
</I>&gt;<i> Both Vampire and the new mod_python 3.3 implement a module importer  
</I>&gt;<i> which
</I>&gt;<i> tracks child imports and will correctly import parent modules when  
</I>&gt;<i> a child changes.
</I>&gt;<i> In fact it is the Vampire module importer which was used as basis  
</I>&gt;<i> for 3.3 version.
</I>&gt;<i>
</I>&gt;<i> This works even if 'from bar import bar' is used as they intercept  
</I>&gt;<i> the 'import'
</I>&gt;<i> statement and when an import is performed from inside a module  
</I>&gt;<i> which was
</I>&gt;<i> already imported using the module importer, it will use the module  
</I>&gt;<i> importer for
</I>&gt;<i> the 'import' as well. Ie., no need to use apache.import_module()  
</I>&gt;<i> explicitly. If the
</I>&gt;<i> module being imported using 'import' is in another directory  
</I>&gt;<i> though, it is necessary
</I>&gt;<i> to specify an option declaring the search path for the modules.  
</I>&gt;<i> This is a path which
</I>&gt;<i> is distinct from PythonPath as new importer will not use any module  
</I>&gt;<i> in PythonPath
</I>&gt;<i> as a candidate for reloading as that causes lots of problems.
</I>&gt;<i>
</I>&gt;<i> Anyway, end result is that with these module importers, you can  
</I>&gt;<i> update a base
</I>&gt;<i> class template, regenerate Cheetah Python class and anything which  
</I>&gt;<i> extends
</I>&gt;<i> from it will be automatically reloaded along with the base class.
</I>&gt;<i>
</I>&gt;&gt;<i> And sometimes I am not importing a compiled template in main, but  
</I>&gt;&gt;<i> create a new template from a text/tmpl file
</I>&gt;&gt;<i> `t = Template(file = &quot;foobar.tmpl&quot;, searchList = [dict, obj])`
</I>&gt;&gt;<i> What does creating a template on the fly like this, mean for  
</I>&gt;&gt;<i> reloading a changed inherited template?
</I>&gt;<i>
</I>&gt;<i> Not sure. Does Cheetah use a caching system of its own for this so  
</I>&gt;<i> that it isn't
</I>&gt;<i> loading them from disk all the time and does it reload the tmpl  
</I>&gt;<i> file if it has changed
</I>&gt;<i> on disk. I can't remember what it does and it may have changed  
</I>&gt;<i> since when I
</I>&gt;<i> was more actively looking at it.
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> This second file only works if I add /var/www/app/templates to my
</I>&gt;&gt;&gt;&gt;<i> PythonPath.  And, due to (2) above, I then also have to add
</I>&gt;&gt;&gt;&gt;<i> /var/www/app to PythonPath.  Is this really necessary?=
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> With the version of mod_python you are using, yes it is necessary.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am also adding the templates directory to my PythonPath, but  
</I>&gt;&gt;<i> since I am not yet running my code from Apache, I haven't yet  
</I>&gt;&gt;<i> discovered problems with loading the rest of my python modules  
</I>&gt;&gt;<i> from my /var/www/python. But if I hit those issues, I'll now know  
</I>&gt;&gt;<i> how to fix them, ;-)
</I>&gt;<i>
</I>&gt;<i> With new importers, you don't want to be setting PythonPath if you  
</I>&gt;<i> want modules
</I>&gt;<i> to be reloadable. You will need to set the module importers own  
</I>&gt;<i> search path.
</I>&gt;<i>
</I>&gt;&gt;<i> BTW, (OT)
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>    templateModule = apache.import_module(&quot;templates/myTemplate&quot;)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Using '/' in the module name like this is not portable and is  
</I>&gt;&gt;&gt;<i> dependent
</I>&gt;&gt;&gt;<i> on peculiarities of the behaviour of Python on a specific  
</I>&gt;&gt;&gt;<i> platform. It will
</I>&gt;&gt;&gt;<i> not for example work on Mac OS X and also possibly not on Windows.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am working on a mac and also using slashes `/` to delimit my  
</I>&gt;&gt;<i> paths, so no problems there. (Didn't try from mod_python though &amp;  
</I>&gt;&gt;<i> dunno what will happen on Windows).
</I>&gt;<i>
</I>&gt;<i> What version of Python are you using? I know for sure it didn't  
</I>&gt;<i> work with
</I>&gt;<i> Python (2.3) on Panther. I also don't think it worked with Python  
</I>&gt;<i> (2.3.5)
</I>&gt;<i> on Tiger. If you are using Python 2.4 or later which you installed  
</I>&gt;<i> yourself,
</I>&gt;<i> it is entirely possible it may work.
</I>&gt;<i>
</I>&gt;&gt;<i> However I know of portability issues, so I am only using paths/ 
</I>&gt;&gt;<i> with/slashes in my configuration files, if I need to create a path  
</I>&gt;&gt;<i> in code I'm using os.path.join()
</I>&gt;<i>
</I>&gt;<i> Depending on the source of the path, one should actually use  
</I>&gt;<i> posixpath functions
</I>&gt;<i> sometimes instead of os.path. This is especially the case of  
</I>&gt;<i> working on req.uri and
</I>&gt;<i> sometimes on req.filename. This is because Apache supplies both of  
</I>&gt;<i> them as
</I>&gt;<i> POSIXish style paths and using os.path functions on Windows can  
</I>&gt;<i> screw things
</I>&gt;<i> up as it introduces back slashes.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> Things are a bit easier to manage and easier to predict when  
</I>&gt;&gt;&gt;<i> mod_python 3.3
</I>&gt;&gt;&gt;<i> can be used. Version 3.3 of mod_python hasn't been released yet,  
</I>&gt;&gt;&gt;<i> but is quite
</I>&gt;&gt;&gt;<i> close.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am eagerly awaiting :-)
</I>&gt;&gt;<i> best
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> dirk
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> -----------------------------
</I>&gt;&gt;<i> Dirk van Oosterbosch
</I>&gt;&gt;<i> de Wittenstraat 225
</I>&gt;&gt;<i> 1052 AT Amsterdam
</I>&gt;&gt;<i> the Netherlands
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> <A HREF="http://labs.ixopusada.com">http://labs.ixopusada.com</A>
</I>&gt;&gt;<i> -----------------------------
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On 28-okt-2006, at 5:32, Graham Dumpleton wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On 28/10/2006, at 7:44 AM, Sebastian Celis wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Hello,
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I am new to this list and have just recently begun to work on a
</I>&gt;&gt;&gt;&gt;<i> project where I wish to use mod_python.publisher and cheetah to  
</I>&gt;&gt;&gt;&gt;<i> drive
</I>&gt;&gt;&gt;&gt;<i> an entire web application.  I apologize if the following topics  
</I>&gt;&gt;&gt;&gt;<i> have
</I>&gt;&gt;&gt;&gt;<i> been discussed to death recently, but I have read through the
</I>&gt;&gt;&gt;&gt;<i> documentation on both sites and have searched through the  
</I>&gt;&gt;&gt;&gt;<i> mailing-list
</I>&gt;&gt;&gt;&gt;<i> archives and while I have seen similar discussions, I have yet  
</I>&gt;&gt;&gt;&gt;<i> to find
</I>&gt;&gt;&gt;&gt;<i> definitive answers.  I am able to get most things to work,  
</I>&gt;&gt;&gt;&gt;<i> however I
</I>&gt;&gt;&gt;&gt;<i> can't help but feel that there are better ways of approaching  
</I>&gt;&gt;&gt;&gt;<i> some of
</I>&gt;&gt;&gt;&gt;<i> my situations.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> First, I'll quickly describe my directory structure:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> /var/www/app -- The base directory to the web application.  This  
</I>&gt;&gt;&gt;&gt;<i> will
</I>&gt;&gt;&gt;&gt;<i> directly contain most of the python files that correspond  
</I>&gt;&gt;&gt;&gt;<i> directly to
</I>&gt;&gt;&gt;&gt;<i> URLs.  For example, index.py, login.py, etc.  In this directory.
</I>&gt;&gt;&gt;&gt;<i> /var/www/app/templates -- Contains all of my cheetah templates.
</I>&gt;&gt;&gt;&gt;<i> /var/www/app/include -- Contains the python utility modules I am
</I>&gt;&gt;&gt;&gt;<i> writing specifically for this application.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Now, onto the questions.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> 1) Importing compiled cheetah templates
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Assume I have code like the following in /var/www/app/test1.py
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> ######################################
</I>&gt;&gt;&gt;&gt;<i> from mod_python import apache
</I>&gt;&gt;&gt;&gt;<i> from Cheetah.Template import Template
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> def index(req):
</I>&gt;&gt;&gt;&gt;<i>    req.content_type = &quot;text/html&quot;
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>    dict = {'title': 'My Title!', 'message': 'Hello world!'}
</I>&gt;&gt;&gt;&gt;<i>    templateModule = apache.import_module(&quot;templates/myTemplate&quot;)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Using '/' in the module name like this is not portable and is  
</I>&gt;&gt;&gt;<i> dependent
</I>&gt;&gt;&gt;<i> on peculiarities of the behaviour of Python on a specific  
</I>&gt;&gt;&gt;<i> platform. It will
</I>&gt;&gt;&gt;<i> not for example work on Mac OS X and also possibly not on Windows.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>    t = getattr(templateModule, &quot;myTemplate&quot;)()
</I>&gt;&gt;&gt;&gt;<i>    searchList = t.searchList()
</I>&gt;&gt;&gt;&gt;<i>    searchList.insert(0, dict)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>    return(t.respond())
</I>&gt;&gt;&gt;&gt;<i> ######################################
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Is this the best way to import template modules and then  
</I>&gt;&gt;&gt;&gt;<i> evaluate them?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> No, in as much as you are having to create a parallel hierarchy  
</I>&gt;&gt;&gt;<i> of publisher
</I>&gt;&gt;&gt;<i> handlers for each Cheetah page. You would be better off using a  
</I>&gt;&gt;&gt;<i> custom
</I>&gt;&gt;&gt;<i> handler which does the dispatch direct to the compiled Cheetah  
</I>&gt;&gt;&gt;<i> template
</I>&gt;&gt;&gt;<i> classes. See the mod_python handler described in:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   <A HREF="http://wiki.cheetahtemplate.org/cheetah-recipes.html">http://wiki.cheetahtemplate.org/cheetah-recipes.html</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> 2) Modifying PythonPath prevents modules from being imported
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Inside file /var/www/app/test2.py, I have the following code:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> import config
</I>&gt;&gt;&gt;&gt;<i> (or)
</I>&gt;&gt;&gt;&gt;<i> config = apache.import_module(&quot;config&quot;)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Both of these commands load /var/www/app/config.py, and seem to  
</I>&gt;&gt;&gt;&gt;<i> work
</I>&gt;&gt;&gt;&gt;<i> fine.  However, if I add
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> PythonPath &quot;['/var/www/app/templates']+sys.path&quot;
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> to my apache configuration, I get an error next time I run  
</I>&gt;&gt;&gt;&gt;<i> test2.py.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i> Mod_python error: &quot;PythonHandler mod_python.publisher&quot;
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Traceback (most recent call last):
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  File &quot;/usr/lib/python2.4/site-packages/mod_python/apache.py&quot;, line
</I>&gt;&gt;&gt;&gt;<i> 299, in HandlerDispatch
</I>&gt;&gt;&gt;&gt;<i>    result = object(req)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  File &quot;/usr/lib/python2.4/site-packages/mod_python/publisher.py&quot;,
</I>&gt;&gt;&gt;&gt;<i> line 213, in handler
</I>&gt;&gt;&gt;&gt;<i>    published = publish_object(req, object)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  File &quot;/usr/lib/python2.4/site-packages/mod_python/publisher.py&quot;,
</I>&gt;&gt;&gt;&gt;<i> line 412, in publish_object
</I>&gt;&gt;&gt;&gt;<i>    return publish_object(req,util.apply_fs_data(object,  
</I>&gt;&gt;&gt;&gt;<i> req.form, req=req))
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  File &quot;/usr/lib/python2.4/site-packages/mod_python/util.py&quot;, line
</I>&gt;&gt;&gt;&gt;<i> 439, in apply_fs_data
</I>&gt;&gt;&gt;&gt;<i>    return object(**args)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  File &quot;/var/www/app/test2.py&quot;, line 8, in index
</I>&gt;&gt;&gt;&gt;<i>    config = apache.import_module(&quot;config&quot;)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  File &quot;/usr/lib/python2.4/site-packages/mod_python/apache.py&quot;, line
</I>&gt;&gt;&gt;&gt;<i> 461, in import_module
</I>&gt;&gt;&gt;&gt;<i>    f, p, d = imp.find_module(parts[i], path)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> ImportError: No module named config
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Why does this initially work but then stop working once I add a
</I>&gt;&gt;&gt;&gt;<i> directory to my path?  I can fix it by adding '/var/www/app' to my
</I>&gt;&gt;&gt;&gt;<i> PythonPath as well, but I don't understand why it didn't work  
</I>&gt;&gt;&gt;&gt;<i> before
</I>&gt;&gt;&gt;&gt;<i> that.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> That is just how mod_python has always worked. Setting PythonPath
</I>&gt;&gt;&gt;<i> stops mod_python looking in the directory the handler was specified
</I>&gt;&gt;&gt;<i> for. Yes it is a pain. FWIW, this behaviour changes in mod_python  
</I>&gt;&gt;&gt;<i> 3.3
</I>&gt;&gt;&gt;<i> where the whole issue of module importing is dealt with a bit  
</I>&gt;&gt;&gt;<i> differently
</I>&gt;&gt;&gt;<i> and is much more consistent and predictable.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Current versions of mod_python have a lot of issues when it comes
</I>&gt;&gt;&gt;<i> to the module importer. You should really have a read of:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   <A HREF="http://www.dscpl.com.au/wiki/ModPython/Articles/">http://www.dscpl.com.au/wiki/ModPython/Articles/</A> 
</I>&gt;&gt;&gt;<i> ModuleImportingIsBroken
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> 3) Cheetah and #include
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I have read a lot about why mod_python sets the current working
</I>&gt;&gt;&gt;&gt;<i> directory to '/', but this seems to be causing some larger problems
</I>&gt;&gt;&gt;&gt;<i> when cheetah comes into play.  (3) and (4) discuss two issues  
</I>&gt;&gt;&gt;&gt;<i> that I
</I>&gt;&gt;&gt;&gt;<i> am having trouble with.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Here is /var/www/app/templates/testPage.tmpl:
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i> #include 'header_include.tmpl'
</I>&gt;&gt;&gt;&gt;<i> &lt;head&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;title&gt;$title&lt;/title&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;/head&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;body&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;p&gt;$message&lt;/p&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;/body&gt;
</I>&gt;&gt;&gt;&gt;<i> #include 'footer_include.tmpl'
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> However, as this actually tries to load /header_include.tmpl and
</I>&gt;&gt;&gt;&gt;<i> /footer_include.tmpl instead of the ones located in my templates
</I>&gt;&gt;&gt;&gt;<i> directory, this will not work.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> If you are going to use compiled templates, you are possibly  
</I>&gt;&gt;&gt;<i> better off using
</I>&gt;&gt;&gt;<i> a site page base class and have specific pages extend that page.  
</I>&gt;&gt;&gt;<i> These
</I>&gt;&gt;&gt;<i> common blocks are then accessible through the base class. This  
</I>&gt;&gt;&gt;<i> means you
</I>&gt;&gt;&gt;<i> get the benefit of compiled code for the included blocks as well,  
</I>&gt;&gt;&gt;<i> instead of
</I>&gt;&gt;&gt;<i> it having to be interpreted each time.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I came up with two workarounds,
</I>&gt;&gt;&gt;&gt;<i> however I don't really love either:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> a)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i> #include os.path.join(os.path.dirname(__file__),  
</I>&gt;&gt;&gt;&gt;<i> 'header_include.tmpl')
</I>&gt;&gt;&gt;&gt;<i> &lt;head&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;title&gt;$title&lt;/title&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;/head&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;body&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;p&gt;$message&lt;/p&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;/body&gt;
</I>&gt;&gt;&gt;&gt;<i> #include os.path.join(os.path.dirname(__file__),  
</I>&gt;&gt;&gt;&gt;<i> 'footer_include.tmpl')
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> b)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Actually pass $templatesDir into all of my templates and then  
</I>&gt;&gt;&gt;&gt;<i> instead call:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i> #include os.path.join(templatesDir, 'header_include.tmpl')
</I>&gt;&gt;&gt;&gt;<i> &lt;head&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;title&gt;$title&lt;/title&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;/head&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;body&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;p&gt;$message&lt;/p&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;/body&gt;
</I>&gt;&gt;&gt;&gt;<i> #include os.path.join(templatesDir, 'footer_include.tmpl')
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I guess I'm leaning toward (a), but both seem cumbersome and slower
</I>&gt;&gt;&gt;&gt;<i> than necessary.  Is there a better way to do this?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> If my memory of Cheetah is correct, then extending from a site  
</I>&gt;&gt;&gt;<i> page which
</I>&gt;&gt;&gt;<i> has reusable bits like this as I describe above is better.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> 4) Cheetah and inheritance
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Assume these two files:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> /var/www/app/templates/overall_base.tmpl
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
</I>&gt;&gt;&gt;&gt;<i>          &quot;<A HREF="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;</A>&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;html xmlns=&quot;<A HREF="http://www.w3.org/1999/xhtml&quot;">http://www.w3.org/1999/xhtml&quot;</A> xml:lang=&quot;en&quot;&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;head&gt;
</I>&gt;&gt;&gt;&gt;<i>    &lt;title&gt;$title&lt;/title&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;/head&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;body&gt;
</I>&gt;&gt;&gt;&gt;<i>    $bodyContent
</I>&gt;&gt;&gt;&gt;<i> &lt;/body&gt;
</I>&gt;&gt;&gt;&gt;<i> &lt;/html&gt;
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> /var/www/app/templates/overall_base_extender.tmpl
</I>&gt;&gt;&gt;&gt;<i> ###
</I>&gt;&gt;&gt;&gt;<i> #overall_base = apache.import_module(&quot;overall_base&quot;)
</I>&gt;&gt;&gt;&gt;<i> (or)
</I>&gt;&gt;&gt;&gt;<i> #from overall_base import overall_base
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> #extends overall_base
</I>&gt;&gt;&gt;&gt;<i> #def title
</I>&gt;&gt;&gt;&gt;<i> Welcome to Foo
</I>&gt;&gt;&gt;&gt;<i> #end def
</I>&gt;&gt;&gt;&gt;<i> #def bodyContent
</I>&gt;&gt;&gt;&gt;<i> Hello world!
</I>&gt;&gt;&gt;&gt;<i> #end def
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> This second file only works if I add /var/www/app/templates to my
</I>&gt;&gt;&gt;&gt;<i> PythonPath.  And, due to (2) above, I then also have to add
</I>&gt;&gt;&gt;&gt;<i> /var/www/app to PythonPath.  Is this really necessary?=
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> With the version of mod_python you are using, yes it is necessary.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> #overall_base = apache.import_module(&quot;overall_base&quot;,
</I>&gt;&gt;&gt;&gt;<i> path=[os.path.dirname(__file__)])
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> doesn't seem to work inside the cheetah template file.  Even
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> #sys.path.append(os.path.dirname(__file__))
</I>&gt;&gt;&gt;&gt;<i> #overall_base = apache.import_module(&quot;overall_base&quot;)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> That one I am not sure about. You may be hitting one of the other  
</I>&gt;&gt;&gt;<i> problems
</I>&gt;&gt;&gt;<i> with PythonPath based module importing which is you can't easily  
</I>&gt;&gt;&gt;<i> have the
</I>&gt;&gt;&gt;<i> same name module in different directories and be sure you import  
</I>&gt;&gt;&gt;<i> the one
</I>&gt;&gt;&gt;<i> you want.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In general I wouldn't recommend using apache.import_module() within
</I>&gt;&gt;&gt;<i> Cheetah templates explicitly.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> doesn't seem to work.  Is there any way to get inheriting  
</I>&gt;&gt;&gt;&gt;<i> templates to
</I>&gt;&gt;&gt;&gt;<i> work without modifying PythonPath to include all the directories  
</I>&gt;&gt;&gt;&gt;<i> where
</I>&gt;&gt;&gt;&gt;<i> my base templates might be located?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Not really.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I apologize for the huge length of this e-mail.  I am still  
</I>&gt;&gt;&gt;&gt;<i> fairly new
</I>&gt;&gt;&gt;&gt;<i> to mod_python and cheetah, but so far I really like what I see.  I
</I>&gt;&gt;&gt;&gt;<i> just feel like there are a few issues I need to wrap my head around
</I>&gt;&gt;&gt;&gt;<i> before I can really dive into developing applications.  Any  
</I>&gt;&gt;&gt;&gt;<i> pointers
</I>&gt;&gt;&gt;&gt;<i> or help with these issues that you can provide would be greatly
</I>&gt;&gt;&gt;&gt;<i> appreciated.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Things are a bit easier to manage and easier to predict when  
</I>&gt;&gt;&gt;<i> mod_python 3.3
</I>&gt;&gt;&gt;<i> can be used. Version 3.3 of mod_python hasn't been released yet,  
</I>&gt;&gt;&gt;<i> but is quite
</I>&gt;&gt;&gt;<i> close. If you want to try the source for mod_python out of the  
</I>&gt;&gt;&gt;<i> Subversion
</I>&gt;&gt;&gt;<i> repository, then can suggest better ways of doing things.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Graham
</I>&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;<i> Mod_python mailing list
</I>&gt;&gt;&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;&gt;&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mod_python mailing list
</I>&gt;&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>&gt;<i>
</I>




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022420.html">[mod_python] Building a web application using Cheetah and
	mod_python
</A></li>
	<LI>Next message: <A HREF="022411.html">[mod_python] Caching pages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22435">[ date ]</a>
              <a href="thread.html#22435">[ thread ]</a>
              <a href="subject.html#22435">[ subject ]</a>
              <a href="author.html#22435">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
