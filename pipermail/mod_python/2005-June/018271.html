<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Spawning Long Running Processes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Spawning%20Long%20Running%20Processes&In-Reply-To=CC1ECBF7-F1DE-44EE-9DA8-F91581BE9BB2%40btinternet.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018268.html">
   <LINK REL="Next"  HREF="018276.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Spawning Long Running Processes</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Spawning%20Long%20Running%20Processes&In-Reply-To=CC1ECBF7-F1DE-44EE-9DA8-F91581BE9BB2%40btinternet.com"
       TITLE="[mod_python] Spawning Long Running Processes">grahamd at dscpl.com.au
       </A><BR>
    <I>Sat Jun  4 00:19:21 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="018268.html">[mod_python] Spawning Long Running Processes
</A></li>
        <LI>Next message: <A HREF="018276.html">[mod_python] Spawning Long Running Processes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18271">[ date ]</a>
              <a href="thread.html#18271">[ thread ]</a>
              <a href="subject.html#18271">[ subject ]</a>
              <a href="author.html#18271">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On 04/06/2005, at 4:56 AM, Michael Rushton wrote:

&gt;<i> Hello,
</I>&gt;<i> What is the best way to spawn a process from a mod_python that could 
</I>&gt;<i> take several hours to complete?
</I>
How much data needs to be communicated between mod_python running under
Apache and the process doing the processing and generation of the file
at initiation of the process and then later?

&gt;<i> I am trying to write a handler that when accessed for the first time 
</I>&gt;<i> spawns a long running process that writes to a file. On subsequent 
</I>&gt;<i> accesses, the handler would show the contents of the file produced by 
</I>&gt;<i> the long process, refreshing the page occasionally with meta refresh 
</I>&gt;<i> tags.
</I>&gt;<i>
</I>&gt;<i> I have had a stab at achieving this by double forking the process. 
</I>&gt;<i> This however, has had the disadvantage that for really long running 
</I>&gt;<i> processes   the forked processes still seem to be bound to port 80 
</I>&gt;<i> thus preventing httpd daemon restarts. A problem when you want to 
</I>&gt;<i> update apache configuration settings.
</I>&gt;<i>
</I>&gt;<i> What am I doing wrong? And what is the accepted way for spawning long 
</I>&gt;<i> lived processes from mod_python?
</I>&gt;<i>
</I>&gt;<i> I would be very grateful if someone could point me to some source 
</I>&gt;<i> examples that show how to achieve this.
</I>
I would avoid forking and perhaps look at a system where you always
have a persistent back end process running all the time. Ie., it would
not be created just at the time the request came in but would already
exist, ready and waiting.

When a request comes in, the mod_python code could trigger an XML-RPC
request, or some other form of interprocess communications, which asks
the long lived back end process to start off what it needs to do to 
create
the file. Provided that the back end process is not written so as to
completely block while generating the file, a subsequent request could
again use something like XML-RPC to query whether it has finished or
at least where it is up to. When it gets a positive response that the
back end processing has finished, if it is a small amount of data it
could be returned in the XML-RPC response, or if a lot, the mod_python
side could just be returned the name of the file which it then tells
Apache to deliver back as the response.

For one example of a package that could be used to implement such a
back end system, have a look at OSE (<A HREF="http://ose.sourceforge.net">http://ose.sourceforge.net</A>). This
has the means using event driven models of programming or appropriate
use of threads to allow a long running job to run in the back end system
but still allow the system to be communicable using XML-RPC or over
its own messaging system. Both these communication means can be accessed
from mod_python handlers.

Anyway, have a look at the documentation for the Python wrappers for
OSE. You may not like OSE because at its core it is C++ (not that you
have to even use C++), but it may give you some ideas. Can help if you
are interested in going this path.

Graham

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018268.html">[mod_python] Spawning Long Running Processes
</A></li>
	<LI>Next message: <A HREF="018276.html">[mod_python] Spawning Long Running Processes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18271">[ date ]</a>
              <a href="thread.html#18271">[ thread ]</a>
              <a href="subject.html#18271">[ subject ]</a>
              <a href="author.html#18271">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
