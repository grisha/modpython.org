<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Threading and apache.import_module
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Threading%20and%20apache.import_module&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018420.html">
   <LINK REL="Next"  HREF="018423.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Threading and apache.import_module</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Threading%20and%20apache.import_module&In-Reply-To="
       TITLE="[mod_python] Threading and apache.import_module">grahamd at dscpl.com.au
       </A><BR>
    <I>Sun Jun 19 18:34:04 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="018420.html">[mod_python] StringField encoding?
</A></li>
        <LI>Next message: <A HREF="018423.html">[mod_python] Threading and apache.import_module
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18421">[ date ]</a>
              <a href="thread.html#18421">[ thread ]</a>
              <a href="subject.html#18421">[ subject ]</a>
              <a href="author.html#18421">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>michael bayer wrote ..
&gt;<i> I just searched around for this, and hey youre right, it does.     
</I>&gt;<i> Myghty imports &quot;in-memory&quot; modules in a similar way (i.e. via  
</I>&gt;<i> imp.new_module + exec)....but I hadnt thought of just bypassing  
</I>&gt;<i> sys.modules altogether.  A &quot;request-level&quot; module really doesnt need  
</I>&gt;<i> to be generally importable so that now makes sense.
</I>
Unfortunately, if you want an alternate module import system to support
packages in a useful way, you don't have a choice but to still place loaded
modules into sys.modules. The key though is knowing that it isn't actually
necessary to name the module with its true module name. It can instead
be an arbitrary name based on the path name to the &quot;.py&quot; file. The name
can't be too long though as you run up against name length restrictions
in Python. Something like a md5 hexdigest of the full pathname generally
works okay. That said, the only problem with trying to support packages
is that dependency management can become hellish. It isn't enough to
simply reload the single file in a package which has changed, you must
reload the whole package because of the interdependencies that can exist
between the modules in the package. Also, if only one file in the package
is changed, anything dependent on any part of the module will need to
be reloaded at the next opportunity.

&gt;<i> I would most like to find a way to do this while also taking  
</I>&gt;<i> advantage of .pyc files (seems like, create .pyc file if it doesnt  
</I>&gt;<i> exist, else if it exists, read four bytes + one long value, then use  
</I>&gt;<i> marshal.load() to create a code object, then exec that).
</I>
I would advise against trying to accomodate &quot;.pyc&quot; files. If you were to
do this you will in practice have to monitor the timestamps on both the
&quot;.py&quot; and &quot;.pyc&quot; files and contend with issues such as what to do when
the &quot;.pyc&quot; file is removed but the &quot;.py&quot; still exists but you were originally
loaded from the &quot;.pyc&quot; file. Similarly, what do you do if you are loaded
from the &quot;.pyc&quot; file and the &quot;.py&quot; file is removed. Does this imply that
the user is intending the page to now no longer be available. Another
cases is what do you do if you are loaded from the &quot;.pyc&quot; file and the
&quot;.py&quot; file modification time is changed to be older than what it was before.
Do you take this as meaning that an older file has been restored and
that should be used instead. As you can see you have to make various
assumptions and in some respects hope for the best. Although it can
be made to work in a reasonably sensible way, I found it complicates
the code unnecessarily and not worth the trouble, especially when
Apache generally runs as a user where &quot;.pyc&quot; files can't be created in
the first place.

Graham


</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018420.html">[mod_python] StringField encoding?
</A></li>
	<LI>Next message: <A HREF="018423.html">[mod_python] Threading and apache.import_module
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18421">[ date ]</a>
              <a href="thread.html#18421">[ thread ]</a>
              <a href="subject.html#18421">[ subject ]</a>
              <a href="author.html#18421">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
