<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Complicated GET configuration
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Complicated%20GET%20configuration&In-Reply-To=20020816215137.GH11141%40fullfactor.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001758.html">
   <LINK REL="Next"  HREF="001763.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Complicated GET configuration</H1>
    <B>Hunter Matthews</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Complicated%20GET%20configuration&In-Reply-To=20020816215137.GH11141%40fullfactor.com"
       TITLE="[mod_python] Complicated GET configuration">thm at duke.edu
       </A><BR>
    <I>Fri Aug 16 20:12:01 EST 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="001758.html">[mod_python] Complicated GET configuration
</A></li>
        <LI>Next message: <A HREF="001763.html">[mod_python] Complicated GET configuration
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1762">[ date ]</a>
              <a href="thread.html#1762">[ thread ]</a>
              <a href="subject.html#1762">[ subject ]</a>
              <a href="author.html#1762">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2002-08-16 at 17:51, Ian Clelland wrote:
&gt;<i> On Fri, Aug 16, 2002 at 05:05:28PM -0400, Hunter Matthews wrote:
</I>&gt;<i> &gt; If anyone on the list has any ideas why the authz handler, which
</I>&gt;<i> &gt; _looked_ like the handler I should use (using HTTP request headers to
</I>&gt;<i> &gt; determine if a client was authorized to make this request), isn't
</I>&gt;<i> &gt; working, I'd still appreciate knowing. 
</I>&gt;<i>  
</I>&gt;<i> After playing with it for about 20 minutes, I managed to get your authorization handler to run on my machine. This appears to be a minimal configuration:
</I>&gt;<i> 
</I>&gt;<i> Apache http.conf:
</I>&gt;<i> 
</I>&gt;<i> &lt;VirtualHost *:80&gt;
</I>&gt;<i>   ServerName pytest.zoostation
</I>&gt;<i>   DocumentRoot /var/local/apache/htdocs/pytest
</I>&gt;<i>   Alias /XMLRPC/$RHN /home/ian/pytest
</I>&gt;<i> 
</I>&gt;<i>   &lt;Directory /home/pytest&gt;
</I>&gt;<i>     Options FollowSymLinks
</I>&gt;<i>     AllowOverride None
</I>&gt;<i>   &lt;/Directory&gt;
</I>&gt;<i> 
</I>&gt;<i>   &lt;Location ~ &quot;/XMLRPC$&quot;&gt;
</I>&gt;<i>     PythonPath &quot;sys.path+['/home/ian/src/pytest']&quot;
</I>&gt;<i>     SetHandler python-program
</I>&gt;<i>     PythonHandler current_apache
</I>&gt;<i>   &lt;/Location&gt;
</I>&gt;<i> 
</I>&gt;<i>   &lt;Location /XMLRPC/$RHN&gt;
</I>&gt;<i>     AuthName 'Restricted Area'
</I>&gt;<i>     AuthType Basic
</I>&gt;<i>     PythonPath &quot;sys.path+['/home/ian/src/pytest']&quot;
</I>&gt;<i>     PythonAuthenHandler current_apache
</I>&gt;<i>     PythonAuthzHandler current_apache
</I>&gt;<i>     require valid-user
</I>&gt;<i>   &lt;/Location&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;/VirtualHost&gt;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> current_apache.py:
</I>&gt;<i> 
</I>&gt;<i> from mod_python import apache
</I>&gt;<i> 
</I>&gt;<i> def authenhandler(req):
</I>&gt;<i>     &quot;&quot;&quot; temp function for testing.
</I>&gt;<i>         this version accepts any username and password
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i> 
</I>&gt;<i>     apache.log_error(&quot;Inside the authenhandler!&quot;, apache.APLOG_NOERRNO &amp; apache.APLOG_ERR)
</I>&gt;<i>     apache.log_error(&quot;method = %s&quot; % req.method, apache.APLOG_NOERRNO &amp; apache.APLOG_ERR)
</I>&gt;<i>     apache.log_error(&quot;headers = %s&quot; % `req.headers_in`, apache.APLOG_NOERRNO &amp; apache.APLOG_ERR)
</I>&gt;<i> 
</I>&gt;<i>     pw = req.get_basic_auth_pw()
</I>&gt;<i>     if req.connection.user == None:
</I>&gt;<i>       return apache.HTTP_UNAUTHORIZED
</I>&gt;<i> 
</I>&gt;<i>     return apache.OK
</I>&gt;<i> 
</I>&gt;<i> def authzhandler(req):
</I>&gt;<i>     &quot;&quot;&quot; temp function for testing
</I>&gt;<i>         this version accepts all users for all uris
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i> 
</I>&gt;<i>     apache.log_error(&quot;Inside the authzhandler!&quot;, apache.APLOG_NOERRNO &amp; apache.APLOG_ERR)
</I>&gt;<i>     apache.log_error(&quot;method = %s&quot; % req.method, apache.APLOG_NOERRNO &amp; apache.APLOG_ERR)
</I>&gt;<i>     apache.log_error(&quot;headers = %s&quot; % `req.headers_in`, apache.APLOG_NOERRNO &amp; apache.APLOG_ERR)
</I>&gt;<i> 
</I>&gt;<i>     return apache.OK
</I>&gt;<i> 
</I>&gt;<i> def handler(req):
</I>&gt;<i>     &quot;&quot;&quot; temp function for testing&quot;&quot;&quot;
</I>&gt;<i> 
</I>&gt;<i>     req.content_type = 'text/html'
</I>&gt;<i>     req.send_http_header()
</I>&gt;<i>     req.write(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Testing&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;)
</I>&gt;<i> 
</I>&gt;<i>     return apache.OK
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Explanation:
</I>&gt;<i> 
</I>&gt;<i> In the Apache configuration, the line which triggers all of the 
</I>&gt;<i> authentication/authorization is the 'require' line. Without this line, 
</I>&gt;<i> the AuthenHandler and AuthzHandler will not be called. 'require 
</I>&gt;<i> valid-user' seems to be sufficient for most cases, since your 
</I>&gt;<i> AuthenHandler can decide who a valid user is, and your AuthzHandler can 
</I>&gt;<i> filter out anyone unauthorized.
</I>&gt;<i> 
</I>&gt;<i> As soon as you add that line, Apache will report an internal server 
</I>&gt;<i> error until you give it an AuthName, AuthType, and some sort of 
</I>&gt;<i> Authentication handler. I added a stub handler which accepts any 
</I>&gt;<i> username and password.
</I>&gt;<i> 
</I>&gt;<i> Once those are all present, then Apache will happily run the 
</I>&gt;<i> AuthzHandler whenever the AuthenHandler returns OK.
</I>
Wow. You are amazing. Thank you.

In this particular application, I don't think the authorization will
work quite like that: 

I don't get a user:password from a browser, this is an xmlrpc client
that sends authentication/authorization information in custom HTTP
headers. 

If you are deciding to allow or deny access based just on the contents
of headers, which Handler would you pick?

In testing here, it appears that PythonHeaderParserHandler works - it
can look at the headers in req.headers_in, and simply return apache.OK
or apache.HTTP_UNAUTHORIZED.

Again, wow. Thank you for deciphering this for me: this is my first
mod_python app.


&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Hope this helps,
</I>&gt;<i> 
</I>&gt;<i> Ian
</I>&gt;<i> &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">ian at veryfresh.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> 
</I>-- 
Hunter Matthews                          Unix / Network Administrator
Office: BioScience 145/244               Duke Univ. Biology Department
Key: F0F88438 / FFB5 34C0 B350 99A4 BB02  9779 A5DB 8B09 F0F8 8438
Never take candy from strangers. Especially on the internet.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001758.html">[mod_python] Complicated GET configuration
</A></li>
	<LI>Next message: <A HREF="001763.html">[mod_python] Complicated GET configuration
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1762">[ date ]</a>
              <a href="thread.html#1762">[ thread ]</a>
              <a href="subject.html#1762">[ subject ]</a>
              <a href="author.html#1762">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
