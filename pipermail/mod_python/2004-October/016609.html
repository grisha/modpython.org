<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] Udate python modules without restarting Apache
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Udate%20python%20modules%20without%20restarting%20Apache&In-Reply-To=08B2AA71-1AA5-11D9-AAF9-000393DCF16E%40dscpl.com.au">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016608.html">
   <LINK REL="Next"  HREF="016610.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] Udate python modules without restarting Apache</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Nicolas Lehuen</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20Udate%20python%20modules%20without%20restarting%20Apache&In-Reply-To=08B2AA71-1AA5-11D9-AAF9-000393DCF16E%40dscpl.com.au"
       TITLE="[mod_python] Udate python modules without restarting Apache">nicolas at lehuen.com
       </A><BR>
    <I>Sun Oct 10 15:12:50 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="016608.html">[mod_python] Udate python modules without restarting Apache
</A></li>
        <LI>Next message: <A HREF="016610.html">[mod_python] Udate python modules without restarting Apache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16609">[ date ]</a>
              <a href="thread.html#16609">[ thread ]</a>
              <a href="subject.html#16609">[ subject ]</a>
              <a href="author.html#16609">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Graham,

First thank you for your thorough anaylisis of the imp module behaviour in a
multi-threaded environment. This reinforce my feeling that NOT using this
module is way better for my publisher since I can precisely understand what
it does without depending on any arcane locking mechanisms. With my
publisher, I know precisely what the locking policy is. Have a look at the
Cache recipe :

<A HREF="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/302997">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/302997</A>

The trick I used to reduce cache contention is to have a two levels locking
scheme. The first level is a lock for the whole cache, used to make sure
that not two entries are created for the same key (here the key is the file
name of the module). The second level is an entry-specific lock which is
used to make sure that a module cannot be initialized by more than one
thread. This two level locking enable multiple threads to handle different
modules concurrently : the possibly lengthy module initialisation process is
done within a module-specific lock, so other thread can initialize other
modules concurrently.

So what happens when a page is accessed by my publisher ?

1) the publisher determines what file is targeted by the http request, just
by using req.filename
2) the publisher get the module keyed by the filename from the module cache
3) the publisher calls a special callable object in the module
(http_handler) or find one by applying acquisition semantics.

At this high level, no locking is required. If the module needs to be
reloaded, the threads which have already reached the step 3 will keep on
using the stale module. Once they are over, the stale module will be
dereferenced and eventually garbage collected (with all objects it
contains). Meanwhile, new threads arriving at step 2 will get the new
module. All is well that ends well.

Now if we study what's happening at step 2 when a module is already up to
date, then we see that we first acquire a lock on the module cache during a
very brief amount of time (just to get the entry for the filename), then a
lock on the module itself for another brief amount of time (just to check
that the module is indeed up to date). Thereafter, all thread are on their
own to do whatever they need in parallel.

So we have indeed a very small contention point where all requests are
serialized, then another small contention point where all requests targeted
at the same module are serialized, then no more contention until the request
is over. That is to say, all the hard work (database requests, file
processing, template rendering etc.) is indeed done in multiple concurrent
threads.

I don't see how this can be done in a better way. In any case, you certainly
should NOT acquire a lock and do all the request processing within this
lock, like you wrote below... This effectively kills any multi-threaded
attempt.

The best part with having properly managed modules is that you can
instantiate long-living objects that are shared between multiple threads in
the modules. The best example is a thread-safe DB connection pool. In fact,
my publisher automatically looks if the module targeted by a request has
special callable objects named 'prepare', 'commit', 'rollback' and
'release'. In those methods, a developper can write some code to manage DB
connections. The net result is that in most of my application, I only have
to write req.cursor to have a safe pooled cursor to the database I use. I
don't have to worry anymore about opening / closing DB connections !

In fact, I extended this behaviour : when a page module is loaded, the
publisher looks for a 'global.pyapp' file which contains a Python module
shared by all modules found in the same directory. This 'global.pyapp' file
is an application-wide module which usually defines global objects such as
the aformentioned DB connection pool, plus the same special methods
'prepare', 'commit', 'rollback', 'release' that are called before the ones
from the targeted module. This is equivalent to the 'global.asa' files found
in Microsoft's ASP.

I plan on releasing my code on the web, but I'm missing the time to build a
proper web site for now...

Anyway, thanks for this interesting discussion :)

Regards,

Nicolas

 

&gt;<i> -----Message d'origine-----
</I>&gt;<i> De : <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">mod_python-bounces at modpython.org</A> 
</I>&gt;<i> [mailto:<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">mod_python-bounces at modpython.org</A>] De la part de 
</I>&gt;<i> Graham Dumpleton
</I>&gt;<i> Envoy&#233; : dimanche 10 octobre 2004 12:14
</I>&gt;<i> &#192; : mod_python user mailing list
</I>&gt;<i> Objet : Re: [mod_python] Udate python modules without 
</I>&gt;<i> restarting Apache
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On 10/10/2004, at 1:55 PM, Graham Dumpleton wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt; The point I am trying to make is that perhaps locking shouldn't 
</I>&gt;<i> &gt; pertain just to the global data and that executable code should in 
</I>&gt;<i> &gt; some way be protected as well.
</I>&gt;<i> &gt; It needs more exploration, but perhaps the module should read 
</I>&gt;<i> &gt; something like the following (untested).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   if not globals().has_key(&quot;datalock&quot;):
</I>&gt;<i> &gt;     # This is a brand new import and we are inside the scope of the
</I>&gt;<i> &gt;     # import lock, so this should all be safe to execute.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     datalock = Lock()
</I>&gt;<i> &gt;     codelock = Lock()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     myglobal1 = None
</I>&gt;<i> &gt;     myglobal2 = None
</I>&gt;<i> &gt;     myglobal3 = None
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     ... arbitrary code to initialise globals
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   codelock.acquire()
</I>&gt;<i> &gt;   datalock.acquire()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   ... extra code to fiddle the globals
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   def modify1(req):
</I>&gt;<i> &gt;     datalock.acquire()
</I>&gt;<i> &gt;     ...
</I>&gt;<i> &gt;     datalock.unlock()
</I>&gt;<i> &gt;     return value
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   def modify2(req,value):
</I>&gt;<i> &gt;     datalock.acquire()
</I>&gt;<i> &gt;     ...
</I>&gt;<i> &gt;     datalock.unlock()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   def _handler(req):
</I>&gt;<i> &gt;     value = modify1(req)
</I>&gt;<i> &gt;     modify2(req,value)
</I>&gt;<i> &gt;     ...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   def handler(req):
</I>&gt;<i> &gt;     # code for this method should never be changed
</I>&gt;<i> &gt;     try:
</I>&gt;<i> &gt;       codelock.acquire()
</I>&gt;<i> &gt;       result = _handler(req)
</I>&gt;<i> &gt;     finally:
</I>&gt;<i> &gt;       codelock.unlock()
</I>&gt;<i> &gt;     return result
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   datalock.unlock()
</I>&gt;<i> &gt;   codelock.unlock()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; What is trying to be done here is using a lock to ensure 
</I>&gt;<i> that any code 
</I>&gt;<i> &gt; itself is not replaced while the handler is being executed. 
</I>&gt;<i> The reason 
</I>&gt;<i> &gt; for two level handler arrangement, is that the lock 
</I>&gt;<i> actually needs to 
</I>&gt;<i> &gt; be acquired outside of the real handler method being 
</I>&gt;<i> called. If it is 
</I>&gt;<i> &gt; done inside, it is too late, as Python has already grabbed the 
</I>&gt;<i> &gt; existing code for handler and if it gets replaced prior to the lock 
</I>&gt;<i> &gt; being acquired, everything may have changed.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Am I being too paranoid? I don't understand enough about 
</I>&gt;<i> how code gets 
</I>&gt;<i> &gt; replaced when a module reload is occurring.
</I>&gt;<i> 
</I>&gt;<i> Hmmm, maybe gone slightly too far here. The code lock 
</I>&gt;<i> effectively serialises access to the handler, which screws up 
</I>&gt;<i> the whole idea of having threads in the first place.
</I>&gt;<i> 
</I>&gt;<i> I really like this idea of using execfile() as described in 
</I>&gt;<i> other email and copying across state variables of interest 
</I>&gt;<i> into a new module, as avoids the need for the code lock 
</I>&gt;<i> anyway as new code constructed in new module.
</I>&gt;<i> 
</I>&gt;<i> --
</I>&gt;<i> Graham Dumpleton (<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">grahamd at dscpl.com.au</A>)
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mod_python mailing list
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">Mod_python at modpython.org</A>
</I>&gt;<i> <A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">http://mailman.modpython.org/mailman/listinfo/mod_python</A>
</I>&gt;<i> 
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016608.html">[mod_python] Udate python modules without restarting Apache
</A></li>
	<LI>Next message: <A HREF="016610.html">[mod_python] Udate python modules without restarting Apache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16609">[ date ]</a>
              <a href="thread.html#16609">[ thread ]</a>
              <a href="subject.html#16609">[ subject ]</a>
              <a href="author.html#16609">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42971867-2', 'modpython.org');
  ga('send', 'pageview');
</script>

</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
