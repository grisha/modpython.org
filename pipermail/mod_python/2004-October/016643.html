<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] RE: Bug in mod_python.c causing
	multiple/redundantinterpreter creation.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20RE%3A%20Bug%20in%20mod_python.c%20causing%0A%09multiple/redundantinterpreter%20creation.&In-Reply-To=20041016144632.2D597173559%40postfix3-1.free.fr">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016639.html">
   <LINK REL="Next"  HREF="016647.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] RE: Bug in mod_python.c causing
	multiple/redundantinterpreter creation.</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20RE%3A%20Bug%20in%20mod_python.c%20causing%0A%09multiple/redundantinterpreter%20creation.&In-Reply-To=20041016144632.2D597173559%40postfix3-1.free.fr"
       TITLE="[mod_python] RE: Bug in mod_python.c causing
	multiple/redundantinterpreter creation.">grahamd at dscpl.com.au
       </A><BR>
    <I>Sun Oct 17 10:32:00 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="016639.html">[mod_python] RE: Bug in mod_python.c causing
	multiple/redundantinterpreter creation.
</A></li>
        <LI>Next message: <A HREF="016647.html">[mod_python] RE: Bug in mod_python.c causing
	multiple/redundantinterpreter creation.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16643">[ date ]</a>
              <a href="thread.html#16643">[ thread ]</a>
              <a href="subject.html#16643">[ subject ]</a>
              <a href="author.html#16643">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I knew there was an issue with apache.py as well, with there being no 
locking,
but didn't mention it in my email with the fix as I wanted to check 
that that
was the source of the other problem I was seeing and make sure I came 
up with
a proper fix.

I was also thinking to suggest using 
imp.acquire_lock()/imp.release_lock(), but
you need to have a fallback for when version of Python older than 2.3 
as those
functions were only introduced in that version.

I'll come up with proper code later, but I was going to suggest 
something like:

if not globals().has_key(&quot;_import_lock&quot;):
   try:
     from threading import Lock
   except:
     class Lock:
       def acquire(self): pass
       def release(self): pass

   _import_lock = Lock()

def import_module(module_name, autoreload=1, log=0, path=None):
     &quot;&quot;&quot;
     Get the module to handle the request. If
     autoreload is on, then the module will be reloaded
     if it has changed since the last import.
     &quot;&quot;&quot;

     _import_lock.acquire()
     try:
	# previous code of apache.import_module
     finally:
         _import_lock.release()

This mess is needed to cater for when threading isn't compiled in to 
Python,
use of an older version of Python that didn't have the imp lock 
functions
and also to avoid risk that apache module might get touched and reloaded
and thus lock being overwritten.

With the way that the apache module caching uses sys.modules as its 
cache
and doesn't keep a separate data structure, I am not sure that a two 
level
locking mechanism would be a good idea. The lock for a two level scheme
would at the moment need to be stored in the module itself, as is 
__mtime__
at present.

Frankly, I reckon the whole thing should be redone using execfile() and 
a
purpose built search routine in place of imp.find_module(). All you 
loose
is the ability to use .pyc/.pyo files. If implemented correctly, you 
would
also loose the restriction in mod_python.publisher about having two 
copies
of the index.py file in different places, but that would actually be a 
gain.

You could optionally, have the support for the __clone__ type method I 
was
talking about before. Ie., in my module reloading mechanism, I load 
into a
fresh module, but a rewrite of the apache scheme, would need to preserve
the behaviour of reloading into the existing one otherwise existing code
might break. The presence of a __clone__ method could turn that off and
instead a new module used in a replacement for the apache scheme.

If one is reimplementing it to this extent, then you could introduce a 
two
level locking mechanism.

On 17/10/2004, at 12:46 AM, Nicolas Lehuen wrote:

&gt;<i> Indeed, having a look at apache.py, I didn't see any locking done to 
</I>&gt;<i> prevent
</I>&gt;<i> the same module from being reloaded multiple times concurrently. What 
</I>&gt;<i> we
</I>&gt;<i> need is to put a lock in the import_module method, so that two threads
</I>&gt;<i> cannot check the freshness of the publisher simultaneously. This can 
</I>&gt;<i> be done
</I>&gt;<i> in a rather brutal way by calling imp.acquire_lock() at the beginning 
</I>&gt;<i> of
</I>&gt;<i> import_module, put a try/finally block around the code of the function 
</I>&gt;<i> and
</I>&gt;<i> call imp.release_lock() in the finally block :
</I>&gt;<i>
</I>&gt;<i> def import_module(module_name, autoreload=1, log=0, path=None):
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Get the module to handle the request. If
</I>&gt;<i>     autoreload is on, then the module will be reloaded
</I>&gt;<i>     if it has changed since the last import.
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>
</I>&gt;<i>     imp.acquire_lock()
</I>&gt;<i>     try:
</I>&gt;<i> 	# previous code of apache.import_module
</I>&gt;<i>     finally:
</I>&gt;<i>         imp.release_lock()
</I>&gt;<i>
</I>&gt;<i> I tested this, and it works as expected. BTW, maybe it wouldn't work 
</I>&gt;<i> without
</I>&gt;<i> your patch, Graham, since I could suddenly see two interpreters with 
</I>&gt;<i> their
</I>&gt;<i> own copy of the mod_python.apache module. But the two fixes are 
</I>&gt;<i> required for
</I>&gt;<i> it to work properly.
</I>&gt;<i>
</I>&gt;<i> Why did I wrote &quot;in a rather brutal way&quot; above ? Because this locking 
</I>&gt;<i> scheme
</I>&gt;<i> is indeed brutal. It is a global lock, so each and every thread who 
</I>&gt;<i> want to
</I>&gt;<i> get its handler must acquire it for a brief amount of time. The 
</I>&gt;<i> problem is
</I>&gt;<i> that if a handler module is reloaded, it locks each and every other 
</I>&gt;<i> thread
</I>&gt;<i> during its reloading, even if they should not be handled by the same 
</I>&gt;<i> module.
</I>&gt;<i> A smarter way to lock would be to use a two-levels locking scheme, as I
</I>&gt;<i> described in my caching recipe in the Python Cookbook. I can implement 
</I>&gt;<i> it
</I>&gt;<i> there if it's ok for everybody.
</I>


--
Graham Dumpleton (<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">grahamd at dscpl.com.au</A>)

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016639.html">[mod_python] RE: Bug in mod_python.c causing
	multiple/redundantinterpreter creation.
</A></li>
	<LI>Next message: <A HREF="016647.html">[mod_python] RE: Bug in mod_python.c causing
	multiple/redundantinterpreter creation.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16643">[ date ]</a>
              <a href="thread.html#16643">[ thread ]</a>
              <a href="subject.html#16643">[ subject ]</a>
              <a href="author.html#16643">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="DISABLEhttp://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
