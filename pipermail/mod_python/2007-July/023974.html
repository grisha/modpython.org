<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mod_python] mod_python 3.3.1 memory leak?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20mod_python%203.3.1%20memory%20leak%3F&In-Reply-To=729753ee0707030422h417dc86ai19dad78ae9550aad%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023973.html">
   <LINK REL="Next"  HREF="023976.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mod_python] mod_python 3.3.1 memory leak?</H1>
<table border=0 width="100%"><tr><td valign="top">
    <B>Graham Dumpleton</B> 
    <A HREF="mailto:mod_python%40modpython.org?Subject=%5Bmod_python%5D%20mod_python%203.3.1%20memory%20leak%3F&In-Reply-To=729753ee0707030422h417dc86ai19dad78ae9550aad%40mail.gmail.com"
       TITLE="[mod_python] mod_python 3.3.1 memory leak?">graham.dumpleton at gmail.com
       </A><BR>
    <I>Tue Jul  3 07:56:27 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023973.html">[mod_python] mod_python 3.3.1 memory leak?
</A></li>
        <LI>Next message: <A HREF="023976.html">[mod_python] mod_python 3.3.1 memory leak?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23974">[ date ]</a>
              <a href="thread.html#23974">[ thread ]</a>
              <a href="subject.html#23974">[ subject ]</a>
              <a href="author.html#23974">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>All I can say is that is simply how Apache works. It is not a problem
with mod_python. To try and explain it, look at simpler code of
ap_rflush() which is one of two Apache functions called when you call
req.write().

AP_DECLARE(int) ap_rflush(request_rec *r)
{
    conn_rec *c = r-&gt;connection;
    apr_bucket_brigade *bb;
    apr_bucket *b;

    bb = apr_brigade_create(r-&gt;pool, c-&gt;bucket_alloc);
    b = apr_bucket_flush_create(c-&gt;bucket_alloc);
    APR_BRIGADE_INSERT_TAIL(bb, b);
    if (ap_pass_brigade(r-&gt;output_filters, bb) != APR_SUCCESS)
        return -1;

    return 0;
}

The important thing here is r-&gt;pool. This is a memory pool which
exists for the life of a request. When you allocate memory from the
memory pool, it will only be reclaimed at the end of the request. Ie.,
it isn't like malloc/free where you can give back a block of memory
using free and it will be reusable straight away.

Now, every time a flush is occurring, it needs to create a bucket
brigade which holds a special flush object. This is then passed down
through the output filters. In this case it causes any pending data to
be flushed out.

Now because the memory for those bucket structures is only reclaimed
at the end of the request, it means if you have a very long running
request which outputs data in small blocks, then there will be an
incremental use of memory because of the need to create the bucket
structures. This memory will be unavailable for use by anything else
until the requests ends.

FWIW, I didn't realise Apache did this either. I can see there are
potentially good reasons for it being done this way, but still was a
surprise.

Graham

On 03/07/07, yubing &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">trueice at gmail.com</A>&gt; wrote:
&gt;<i> oh, sorry, that's my typo in the mail, it should have been:
</I>&gt;<i> ------------------------------
</I>&gt;<i> def pump_file(req):
</I>&gt;<i>     fp = open(&quot;/dev/zero&quot;, &quot;r&quot;)
</I>&gt;<i>     while(True):
</I>&gt;<i>         buf = fp.read(4096)
</I>&gt;<i>         try:
</I>&gt;<i>             req.write(buf)
</I>&gt;<i>             time.sleep(0.1)
</I>&gt;<i>         except:
</I>&gt;<i>             fp.close()
</I>&gt;<i>             break
</I>&gt;<i> -------------------------------
</I>&gt;<i> you can still observe the memory going up slowly
</I>&gt;<i> BTW: I'm using the prefork mpm of apache
</I>&gt;<i>
</I>&gt;<i> On 7/3/07, Graham Dumpleton &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">graham.dumpleton at gmail.com</A> &gt; wrote:
</I>&gt;<i> &gt; On 03/07/07, yubing &lt;<A HREF="http://mailman.modpython.org/mailman/listinfo/mod_python">trueice at gmail.com</A> &gt; wrote:
</I>&gt;<i> &gt; &gt; Our project has a live HTTP video streamer written in python, which
</I>&gt;<i> keeps
</I>&gt;<i> &gt; &gt; pumping a stream out to the client.
</I>&gt;<i> &gt; &gt; The HTTP serving module is a simple mod_python request handler running
</I>&gt;<i> on
</I>&gt;<i> &gt; &gt; Apache 2.2.4 with mod_python 3.3.1 (Python 2.5.1).
</I>&gt;<i> &gt; &gt; The stream is read out of our streaming server via TCP socket, and the
</I>&gt;<i> &gt; &gt; python script just do some simple processing like header building, each
</I>&gt;<i> &gt; &gt; allocated buffer is del-ed after being used.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; The problem is:
</I>&gt;<i> &gt; &gt; We observed that after its running serveral hours, its memory occupation
</I>&gt;<i> &gt; &gt; grows up to serveral hundreds of megabytes and keeps growing in 4k-8k
</I>&gt;<i> &gt; &gt; increment every 1-2 seconds.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Below is a simple testing scriptlet, the memory leaking issue is not so
</I>&gt;<i> &gt; &gt; serious as our live serving module, but you can still observe 4k memory
</I>&gt;<i> &gt; &gt; growing every serveral seconds.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Could anyone help me to figure out the root cause of this issue?
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; --------------------------
</I>&gt;<i> &gt; &gt; import time
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; def pump_file(req):
</I>&gt;<i> &gt; &gt;     while(True):
</I>&gt;<i> &gt; &gt;         fp = open(&quot;/dev/zero&quot;, &quot;r&quot;)
</I>&gt;<i> &gt; &gt;         buf = fp.read(4096)
</I>&gt;<i> &gt; &gt;         try:
</I>&gt;<i> &gt; &gt;             req.write(buf)
</I>&gt;<i> &gt; &gt;             del buf
</I>&gt;<i> &gt; &gt;             time.sleep(0.1)
</I>&gt;<i> &gt; &gt;         except:
</I>&gt;<i> &gt; &gt;             fp.close()
</I>&gt;<i> &gt; &gt;             break
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; BTW, you do realise that you open the file in the loop when it should
</I>&gt;<i> &gt; be outside.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Graham
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> truly yours
</I>&gt;<i> ice
</I></PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023973.html">[mod_python] mod_python 3.3.1 memory leak?
</A></li>
	<LI>Next message: <A HREF="023976.html">[mod_python] mod_python 3.3.1 memory leak?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23974">[ date ]</a>
              <a href="thread.html#23974">[ thread ]</a>
              <a href="subject.html#23974">[ subject ]</a>
              <a href="author.html#23974">[ author ]</a>
         </LI>
       </UL>

</td>
<td align="right" valign="top">
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_color_border = "CCCCCC";
google_color_bg = "FFFFFF";
google_color_link = "000000";
google_color_url = "666666";
google_color_text = "333333";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</table>

<hr>
<a href="http://mailman.modpython.org/mailman/listinfo/mod_python">More information about the Mod_python
mailing list</a><br>
</body></html>
